<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Again Unscarred</title>
  
  <subtitle>别来无恙，欢迎来到我的blog !</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-05T09:53:28.089Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>CharliChen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【YOLO笔记】使用YOLO v2训练自己的数据</title>
    <link href="http://yoursite.com/2018/11/23/%E3%80%90YOLO%E7%AC%94%E8%AE%B0%E3%80%91%E4%BD%BF%E7%94%A8YOLO%20v2%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2018/11/23/【YOLO笔记】使用YOLO v2训练自己的数据/</id>
    <published>2018-11-22T16:15:30.000Z</published>
    <updated>2019-03-05T09:53:28.089Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>这篇文章是在训练YOLO v2过程中的经验总结，我使用YOLO v2训练一组自己的数据，训练后的模型，在阈值为.25的情况下，Recall值是73.84%，Precision 是85.12%。</p></blockquote><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本文用到的darknet代码下载时间为2018-01-31<br>机器配置：4片Tesla P40，CUDA8.0<br>本文主要参考YOLO官网：<a href="http://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">http://pjreddie.com/darknet/yolo/</a><br>需要注意的是，这一训练过程可能只对我自己的训练集有效，仅供参考。</p><h2 id="下载代码"><a href="#下载代码" class="headerlink" title="下载代码"></a>下载代码</h2><p>Darknet的具体安装及使用可以参考官方文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pjreddie/darknet</span><br></pre></td></tr></table></figure><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>YOLO v2默认训练VOC数据集，作者提供了将VOC数据集转成YOLO训练所需格式的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">darknet\scripts\voc_label.py</span><br></pre></td></tr></table></figure><p>为了让YOLO v2能像训练VOC数据集一样训练我的数据集，我将数据转换成以下格式：</p><p>1用于训练的数据集共4348张图片和4348个与图片对应的标记信息。<br>2图片格式为 jpg，分辨率都为800*1280，命名从0000.jpg到4347.jpg。<br>3标记信息格式为txt，命名从0000.txt到4347.txt。<br>4一共4348组信息，选择3912组用于训练（Train），435组用于验证（Validation）。<br>5数据集只包含三个类别：Clickable控件、Inputable控件、Slidable控件。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="准备txt文档"><a href="#准备txt文档" class="headerlink" title="准备txt文档"></a>准备txt文档</h3><p>VOC训练数据集中会自带txt文档，用来指明文件路径，使用自己的数据需要自己生成：</p><ul><li>train.txt文档：用于告诉训练系统哪些图片是用来训练的</li><li>val.txt文档：用于告诉训练系统哪些图片是用于验证的</li></ul><p>文档里包含了所有用于训练或验证的图片的完整路径，每行都是一个图片的完整路径，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/data/darknet/metis/JPEGImages/0000.jpg</span><br><span class="line">/data/darknet/metis/JPEGImages/0001.jpg</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>在代码中，默认VOC数据集是20类，而我要改成3类。</p><p>1 创建data/metis.names文件，保存类别列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clickable</span><br><span class="line">inputable</span><br><span class="line">slidable</span><br></pre></td></tr></table></figure><p>2 创建cfg/metis.data文件，也可以修改cfg/voc.data文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">classes= 3</span><br><span class="line">train  = metis/train.txt</span><br><span class="line">valid  = metis/val.txt</span><br><span class="line">names = metis/metis.names</span><br><span class="line">backup = backup/</span><br></pre></td></tr></table></figure><p>其中，classes 表示类别个数，train指向train.txt文档，valid指向val.txt文档，names指向metis.names文件，backup指向训练时权重文件备份路径。</p><p>3 复制cfg/yolo_voc.cfg文件，命名为cfg/yolo_metis.cfg，根据训练集和机器配置做修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[net]</span><br><span class="line">batch=64   每64张图更新一次权重</span><br><span class="line">subdivisions=8  内存不够大，将batch分为subdivisions个子batch</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">learning_rate=0.001   学习率</span><br><span class="line">max_batches = 1000000  最大迭代次数</span><br><span class="line">policy=steps   按照steps策略调整学习率，还有constant, steps, exp, poly, step, sig, RANDOM</span><br><span class="line">steps=8000,20000   根据batch_num调整学习率</span><br><span class="line">scales=.1,.1    学习率变化的比例，累计相乘</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">[convolutional]</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">filters=40   最后一个卷积层输出的特征图数为5×(classes + 5)</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">[region]</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">classes=3   训练3类</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>4 修改example/yolo.c代码文件<br>开头修改为自己的类别数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *voc_names[] = &#123;&quot;clickable&quot;, &quot;inputable&quot;, &quot;slidable&quot;&#125;;</span><br></pre></td></tr></table></figure><p>train_yolo函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *train_images =&quot; /data/darknet/metis/train.txt&quot;; // train.txt完整路径</span><br><span class="line">char *backup_directory = &quot;/data/darknet/backup/&quot;; // backup路径</span><br></pre></td></tr></table></figure><p>validate_yolo函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *base = &quot;/data/darknet/results/comp4_det_test_&quot;; // 用于保存测试结果</span><br><span class="line">list *plist=get_paths(&quot;/data/darknet/metis/val.txt&quot;); // val.txt完整路径</span><br></pre></td></tr></table></figure><p>validate_yolo_recall函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *base = &quot;/data/darknet/results/comp4_det_test_&quot;; // 用于保存测试结果</span><br><span class="line">list *plist = get_paths(&quot;/data/darknet/metis/val.txt&quot;); // val.txt完整路径</span><br></pre></td></tr></table></figure><p>5 修改example/detector.c代码文件（可选，用于评估模型）<br>validate_detector_recall函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list *plist = get_paths(&quot;/data/darknet/metis/val.txt&quot;); // val.txt完整路径</span><br></pre></td></tr></table></figure><p>validate_detector_recall函数是用来计算输出recall值的，替换下面代码，可同时计算precision值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//fprintf(stderr, &quot;%5d %5d %5d\tRPs/Img: %.2f\tIOU: %.2f%%\tRecall:%.2f%%\n&quot;, i, correct, total, (float)proposals/(i+1), avg_iou*100/total, 100.*correct/total); </span><br><span class="line">fprintf(stderr, &quot;Number: %5d\tCorrect: %5d\tTotal: %5d\tRPs/Img: %.2f\tIOU: %.2f%%\tRecall:%.2f%%\tProposals: %5d\tPrecision: %.2f%%\n&quot;, i, correct, total, (float)proposals/(i+1), avg_iou*100/total, 100.*correct/total, proposals, 100.*correct/(float)proposals);</span><br></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>Darknet在GPU上运行可以得到500倍的提速，编译使用GPU要求显卡是Nvidia卡并且正确安装了CUDA。GPU环境下的编译配置都是在/darknet/Makefile文件中定义的，GPU环境的编译需注意以下几点：</p><p>1 使用GPU方式，更改Makefile前两行GPU和CUDNN的配置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPU=1</span><br><span class="line">CUDNN=1</span><br></pre></td></tr></table></figure><p>2 CUDA的路径默认为/usr/local/cuda/， 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ifeq ($(GPU), 1)</span><br><span class="line">COMMON+= -DGPU -I/usr/local/cuda/include/</span><br><span class="line">CFLAGS+= -DGPU</span><br><span class="line">LDFLAGS+= -L/usr/local/cuda/lib64 -lcuda -lcudart -lcublas -lcurand</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>3 修改NVCC的路径（可选）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NVCC=/usr/local/cuda/bin/nvcc</span><br></pre></td></tr></table></figure><p>4 修改ARCH配置：<br>如果修改上述配置后编译的darknet运行仍报以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Loadingweights from yolo.weights...Done!</span><br><span class="line">CUDA Error:invalid device function</span><br><span class="line">darknet: ./src/cuda.c:21: check_error: Assertion `0&apos; failed.</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>这是因为配置文件Makefile中配置的GPU架构和本机GPU型号不一致导致的。<br>更改前默认配置如下（不同版本可能有变）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ARCH= -gencode arch=compute_30,code=sm_30 \</span><br><span class="line">   -gencode arch=compute_35,code=sm_35 \</span><br><span class="line">   -gencode arch=compute_50,code=[sm_50,compute_50] \</span><br><span class="line">   -gencode arch=compute_52,code=[sm_52,compute_52]</span><br><span class="line">#      -gencode arch=compute_20,code=[sm_20,sm_21] \ This one is deprecated?</span><br><span class="line"># This is what I use, uncomment if you know your arch and want to specify</span><br><span class="line"># ARCH= -gencode arch=compute_52,code=compute_52</span><br></pre></td></tr></table></figure><p>compute_30表示显卡的计算能力是3.0，几款主流GPU的compute capability列表：<br>GTX Titan X：5.2<br>GTX 980：5.2<br>Tesla K80：3.7<br>Tesla K40：3.5<br>Quadro K4200：3.0</p><p>GPU的计算能力及对应的架构可以参考CUDA官方说明文档。</p><p>进入darknet目录，执行编译命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd darknet</span><br><span class="line">make</span><br></pre></td></tr></table></figure><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>按照YOLO的官方指南，下载预训练模型 (76 MB)，放到darkent/目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://pjreddie.com/media/files/darknet19_448.conv.23</span><br></pre></td></tr></table></figure><p>然后开始训练，运行下面的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./darknet detector train cfg/metis.data cfg/yolo-metis.cfg darknet19_448.conv.23 | tee train_log.txt</span><br></pre></td></tr></table></figure><p>训练输出保存到train_log.txt文件，用于可视化分析及参数调整。</p><p><strong>注意：如果学习率设置的比较大，训练结果很容易发散，训练过程输出的log会有nan字样，需要减小学习率后再进行训练。</strong></p><h3 id="多GPU训练"><a href="#多GPU训练" class="headerlink" title="多GPU训练"></a>多GPU训练</h3><p>在darknet上使用多GPU训练需要一定技巧，盲目使用多GPU训练会悲剧的发现损失一直在下降、recall在上升，然而Obj几乎为零,最终得到的权重文件无法预测出bounding box。</p><p>使用多GPU训练前需要先用单GPU训练至Obj有稳定上升的趋势后（我一般在obj大于0.1后切换）再使用backup中备份的weights通过多GPU继续训练。一般情况下使用单GPU训练1000个迭代即可切换到多GPU。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./darknet detector train cfg/metis.data cfg/yolo-metis.cfg backup/yolo-metis_1000.weights -gpus 0,1,2,3 | tee train_log.txt</span><br></pre></td></tr></table></figure><p>其中0,1,2,3是指定的GPU的ID，通过nvidia-smi命令以查询：<br><img src="http://thyrsi.com/t6/676/1551778894x2890202402.png" alt="在这里插入图片描述"><br><strong>注意：使用多GPU训练时，学习率是使用单GPU训练的n倍，n是使用GPU的个数</strong></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>等待训练结束后（有时候没等结束我们的模型就开始发散了），我们需要检查各项指标（如loss）是否达到了我们期望的数值，如果没有，要分析为什么。可视化训练过程的中间参数可以帮助我们分析问题。</p><p>可视化中间参数需用到训练时保存的train_log.txt文件，截取第801次迭代输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Loaded: 8.830000 seconds</span><br><span class="line">Region Avg IOU: 0.274009, Class: 0.964729, Obj: 0.004919, No Obj: 0.002184, Avg Recall: 0.151515,  count: 33</span><br><span class="line">Region Avg IOU: 0.339205, Class: 0.952790, Obj: 0.007317, No Obj: 0.002155, Avg Recall: 0.194805,  count: 77</span><br><span class="line">...</span><br><span class="line">Region Avg IOU: 0.193028, Class: 0.983987, Obj: 0.005020, No Obj: 0.001640, Avg Recall: 0.102273,  count: 88</span><br><span class="line">801: 3.524177, 3.524177 avg, 0.001647 rate, 8.070000 seconds, 205056 images</span><br></pre></td></tr></table></figure><p>每次迭代会输出64行以Region开头的结果和最后一行合并的结果，这里64行是因为配置文件cfg/yolo-metis.cfg中设置batch=64，即每64张图更新一次权重。</p><p><strong>输出各参数的含义：</strong></p><ul><li>Region Avg IOU：平均的IOU，代表预测的bounding box和实际的ground truth的交集除以他们的并集，这个数值越大，说明预测的结果越好，期望该值趋近于1。</li><li>Class：是标注物体的概率，期望该值趋近于1。</li><li>Obj：期望该值趋近于1。</li><li>No Obj：期望该值越来越小但不为零。</li><li>Avg Recall：这个表示平均召回率， 意思是检测出物体的个数除以标注的所有物体个数，期望该值趋近1。</li><li>count：标注的所有物体的个数。如果count = 6， recall = 0.66667，就表示一共有6个物体（可能包含不同类别），然后预测出来了4个，所以Recall就是4/ 6 = 0.66667 。</li><li></li></ul><p>最后一行内容依次是：迭代次数、train loss、avg train loss、learning rate、一次迭代时间、已处理图片数。重点关注train loss和avg train loss，期望这两个值随迭代次数增加而逐渐降低。如果loss增大到几百那就是训练发散了，如果loss在一段时间不变，就需要降低learning rate或者改变batch来加强学习效果。当然也可能是训练已经充分。这个需要自己判断。</p><p>我训练过程中的变化曲线：<br><img src="http://thyrsi.com/t6/676/1551779166x2890202402.png" alt="在这里插入图片描述"></p><p>从损失变化曲线可以看出，模型在2万次迭代后损失下降速度变慢。是因为cfg/yolo-metis.cfg文件中我自定义的学习率变化策略在2万次迭代时会减小十倍，所以损失下降速度降低，最终趋近于平缓。</p><h2 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h2><p>对于detection而言，不要盲目用loss来评判一个模型的好坏。loss应该用作在训练当中判断训练是否正常进行。比如训练一开始loss一直升高，最后NAN，说明学习率大了。</p><p>那应该用哪个数值来评判模型的好坏呢？mAP（平均准确率）是当前的主流标准。</p><p>在darknet训练过程中并不输出precision的结果，所以我们也可以通过recall来判断。recall越接近1.0，就说明模型检测到实际的物体数量越准确。</p><p>前面我们已经修改了example/detector.c代码，使用recall命令可以得到模型的平均recall和precision。另外，我还修改thresh可作为参数，通过-thresh <val>传入，源码中默认thresh=.001。</val></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./darknet detector recall cfg/metis.data cfg/yolo-metis.cfg backup/yolo-metis.backup -thresh 0.25</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Number:     0   Correct:    17  Total:    17    RPs/Img: 17.00  IOU: 89.44%     Recall:100.00%  Proposals:    17    Precision: 100.00%</span><br><span class="line">Number:     1   Correct:    35  Total:    35    RPs/Img: 17.50  IOU: 85.53%     Recall:100.00%  Proposals:    35    Precision: 100.00%</span><br><span class="line">...</span><br><span class="line">Number:   434   Correct:  6447  Total:  8636    RPs/Img: 19.35  IOU: 65.80%     Recall:73.84%   Proposals:   841    Precision: 85.12%</span><br></pre></td></tr></table></figure><p>结果中的参数：</p><ul><li>Correct：正确预测的框的数量。遍历每张图片的Ground Truth，网络会预测出很多的框，对每一Groud Truth框与所有预测出的框计算IoU，在所有IoU中找一个最大值，如果最大值超过预设的阈值，则correct加1。</li><li>Total：实际上Groud Truth框的总数。</li><li>Rps/img：平均每张图片预测出的目标个数。</li><li>Recall：Correct/Total，即预测出的正确框数除以实际的总框数。</li><li>Proposals：总共预测出的框数（包括正确和错误的）。</li><li>Precision：Correct/Proposals，即预测出的正确框数除以预测出的全部框数。</li></ul><p>使用验证集（435张图片及对应标记信息）评估我的模型：在阈值为.25的情况下，Recall值是73.84%，Precision 是85.12%。</p><h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><p>利用已训练好的模型预测图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./darknet detector test cfg/metis.data cfg/yolo-metis.cfg backup/yolo-metis.backup test.png -thresh 0.25</span><br></pre></td></tr></table></figure><p>预测出的结果会保存为predictions.png<br><img src="http://thyrsi.com/t6/676/1551779344x2890202402.png" alt="在这里插入图片描述"></p><h2 id="python调用方式"><a href="#python调用方式" class="headerlink" title="python调用方式"></a>python调用方式</h2><p>调用YOLO的原理是调用编译好的libdarknet.so库文件里的方法。Python ctypes帮助我们使用Python调用C++库里的方法。</p><p>作者提供了python/darknet.py文件，把YOLO库中的C++方法封装成Python模块，调用方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import python.darknet as dn</span><br><span class="line"></span><br><span class="line">dn.set_gpu(0)</span><br><span class="line">net = dn.load_net(&quot;cfg/yolo-metis.cfg&quot;, &quot;backup/yolo-metis.backup&quot;, 0)</span><br><span class="line">meta = dn.load_meta(&quot;cfg/metis.data&quot;)</span><br><span class="line">r = dn.detect(net, meta, &quot;test.png&quot;)</span><br><span class="line">print(r)</span><br></pre></td></tr></table></figure><p>输出结果r是一个一维数组：[(目标1), (目标2), (目标3)]，代表了一共检测到几个目标，每个目标均包含信息：(类名, 类自信度, (目标中心x, 目标中心y, 目标宽度, 目标高度))</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文是我在学习使用YOLO v2训练自己数据过程中的经验总结，主要从工程应用上描述了YOLO v2的使用过程，仅作为大家训练数据时的参考。如果想要详细了解YOLO v2的实现原理，还需要详细阅读源码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;这篇文章是在训练YOLO v2过程中的经验总结，我使用YOLO v2训练一组自己的数据，训练后的模型，在阈值为.25的情况下，Recall值是73.84%，Precision 是85.12%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="yolo，图像识别" scheme="http://yoursite.com/tags/yolo%EF%BC%8C%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>基于springboot+vuejs 打造前后端分离的web平台</title>
    <link href="http://yoursite.com/2018/07/02/%E5%9F%BA%E4%BA%8Espringboot+vuejs%20%E6%89%93%E9%80%A0%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84web%E5%B9%B3%E5%8F%B0/"/>
    <id>http://yoursite.com/2018/07/02/基于springboot+vuejs 打造前后端分离的web平台/</id>
    <published>2018-07-02T03:25:55.000Z</published>
    <updated>2019-03-11T08:41:29.152Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>导语 本文系笔者的工作笔记，根据目前比较流行的前后端分离思想，前后端独立开发独立部署互不影响原则，打造最有效率的web平台。</p></blockquote><p><img src="http://po70nxvk4.bkt.clouddn.com/1530276035_30_w845_h429.gif" alt="预览图"></p><hr><h2 id="0-设计理念"><a href="#0-设计理念" class="headerlink" title="0 设计理念"></a>0 设计理念</h2><ul><li>前后端分离的思想，实现前后端100%分离，独立开发，独立部署，互不影响</li><li>充分复用github上优秀的开源项目，不追求重复造轮子，而是将强大的轮子组装成战车</li><li>追求最实用最轻便的前后端技术，摒弃旧的繁琐的技术，提高开发和维护效率</li><li>追求投入产出比，一份投入即可实现多种测试需求</li></ul><h2 id="1-主要的技术栈"><a href="#1-主要的技术栈" class="headerlink" title="1 主要的技术栈"></a>1 主要的技术栈</h2><ul><li><a href="https://vuejs.org/" title="vuejs" target="_blank" rel="noopener">vuejs</a></li><li><a href="https://nodejs.org/en/" title="nodejs" target="_blank" rel="noopener">nodejs</a></li><li><a href="https://webpack.js.org/" title="webpack" target="_blank" rel="noopener">webpack</a></li><li><a href="http://spring.io/projects/spring-boot" title="springboot" target="_blank" rel="noopener">springboot</a></li><li><a href="https://gradle.org/" title="gradle" target="_blank" rel="noopener">gradle</a></li><li><a href="http://www.nginx.cn/doc/" title="nginx" target="_blank" rel="noopener">nginx</a></li><li><a href="https://www.mysql.com/" title="mysql" target="_blank" rel="noopener">mysql</a></li></ul><h2 id="2-开发环境"><a href="#2-开发环境" class="headerlink" title="2 开发环境"></a>2 开发环境</h2><ul><li>IDE：Intellij IDEA，WebStorm</li><li>JDK：Java8</li><li>Gradle：4.6</li><li>Node.js：6.10.1</li><li>Vue-cli：2.9.3</li></ul><h2 id="3-整体框架搭建"><a href="#3-整体框架搭建" class="headerlink" title="3 整体框架搭建"></a>3 整体框架搭建</h2><blockquote><p>由于此项目100%前后端分离，整体框架分两部分来介绍，IDE环境前端是用WebStorm，后端是Intellij IDEA，主体框架前端是Vuejs，后端是Springboot。前端工程构建打包基于Webpack，后端工程构建打包基于Gradle。</p></blockquote><p>Vue.js是MVVM设计模式中目前最火热的一个前端框架之一，除了性能表现优异之外，与类似React相比，更轻量级、更容易上手。通过Vue中的“单文件组件”特性，更灵活的定义组件，不仅使代码结构更清晰，而且能与任何其他组件进行随意组合，更具复用性。<br>Springboot去除了大量的xml配置文件，简化复杂的依赖管理，配合Gradle等构件工具打成Jar包后，嵌入式Tomcat无需部署WAR包，直接执行java -jar 进行部署运行，方便高效。</p><h3 id="a-环境搭建"><a href="#a-环境搭建" class="headerlink" title="a 环境搭建"></a>a 环境搭建</h3><p><strong>1 . Node.js安装与配置</strong><br>安装过程就不赘述了，网上都有。</p><p><strong>注意一点是安装完nodejs后，在内网用npm命令需要配置代理</strong>，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set proxy http:<span class="comment">//dev-proxy.oa.com:8080</span></span><br><span class="line">npm config set https-proxy http:<span class="comment">//dev-proxy.oa.com:8080</span></span><br></pre></td></tr></table></figure></p><p>为了提高速度，可以使用公司tnpm镜像，通过修改npm的registry的方式来实现 (公司的registry地址为 <a href="http://r.tnpm.oa.com" target="_blank" rel="noopener">http://r.tnpm.oa.com</a>)</p><p><strong>2 . Vue-cli安装</strong><br> Vue-cli是快速构建vuejs单页应用的脚手架，这个可是官方的介绍，这个大家可以上网查找<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tnpm install vue-cli -g</span><br></pre></td></tr></table></figure></p><p>-g :代表全局安装。如果你安装时报错，一般是网络问题，你可以尝试用cnpm来进行安装。安装完成后，可以用vue -V来进行查看 vue-cli的版本号。注意这里的V是大写的。我这里版本号是2.9.3</p><p><strong>3. Webpack安装</strong><br>Webpack 是一个前端资源加载/打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tnpm install webpack -g</span><br></pre></td></tr></table></figure></p><p><strong>4. 安装jdk:1.8</strong><br>安装过程就不赘述了，网上都有。<br><strong>5.安装mysql和数据库管理软件Navicat</strong><br>安装过程就不赘述了，网上都有。<br><strong>6.安装Nginx服务器</strong><br>安装过程就不赘述了，网上都有。<br><strong>7. 安装gradle 4.6</strong><br>安装过程就不赘述了，网上都有。<br><strong>注意一点是安装完gradle后，在内网用gradle命令需要配置代理</strong>。在你的后端项目根目录创建一个<code>gradle.properties</code>文件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemProp.http.proxyHost=dev-proxy.oa.com</span><br><span class="line">systemProp.http.proxyPort=<span class="number">8080</span></span><br><span class="line">systemProp.https.proxyHost=dev-proxy.oa.com</span><br><span class="line">systemProp.https.proxyPort=<span class="number">8080</span></span><br></pre></td></tr></table></figure></p><h3 id="b-构建前端项目工程"><a href="#b-构建前端项目工程" class="headerlink" title="b 构建前端项目工程"></a>b 构建前端项目工程</h3><ol><li>使用vue-cli生成前端vuejs的项目模板。CMD打开终端，进入一个目录，命令行，输入命令：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue init webpack client</span><br></pre></td></tr></table></figure></li></ol><p>其中webpack是用<code>webpack</code>做vue.js的打包工具，client是生成的项目工程模板名称。依次做以下的选择：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Project name --&gt; client</span><br><span class="line">Project description --&gt;  vue.js project</span><br><span class="line">Author --&gt; charlichen</span><br><span class="line">Vue build --&gt; 回车</span><br><span class="line">Install vue-router ? --&gt; y</span><br><span class="line">Use ESlint to lint your code? --&gt; n</span><br><span class="line">Setup unit tests <span class="keyword">with</span> Karma + Mocha? --&gt; n</span><br><span class="line">Setup e2e tests <span class="keyword">with</span> Nightwatch? --&gt; n</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>执行以上步骤后，vue-cli工具就会将项目模板生成在对应的目录，用WebStorm 打开如下图：<br><img src="http://po70nxvk4.bkt.clouddn.com/vue-project.png" alt=""></p></li><li><p>进入项目目录，安装所有依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tnpm install</span><br></pre></td></tr></table></figure></li></ol><p>这样子npm就会根据package.js中的信息下载依赖的模块。安装后client目录下会出现node_modules目录</p><ol start="4"><li>此时需要测试一下vue-cli搭建的web项目是否正确<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#通过npm命令启动node server ：localhost:8080</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li></ol><p>如果这里进展顺利，在你的浏览器输入localhost:8080，会打开一个vue app，类似于下图所示：<br><img src="http://po70nxvk4.bkt.clouddn.com/vue-page.png" alt=""></p><h3 id="c-构建后端项目工程"><a href="#c-构建后端项目工程" class="headerlink" title="c 构建后端项目工程"></a>c 构建后端项目工程</h3><p>1.打开IDEA创建Springboot项目，当然也可以直接访问<a href="https://start.spring.io/" title="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a>在线创建<br><img src="http://po70nxvk4.bkt.clouddn.com/springboot-init.png" alt=""><br>ps：图片里的参数选择，请提前上网熟悉springboot的基础知识即可。</p><p>2.将创建好的springboot工程，导入到IDEA中，设置Gradle的参数配置，如图选项修改为你的Gradle配置的目录，点击ok后开始自动下载项目所需的依赖包<br><img src="http://po70nxvk4.bkt.clouddn.com/springboot-gradle.png" alt=""></p><p>3.修改工程中<code>build.gradle</code>文件，添加你需要的依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">ext &#123;</span><br><span class="line">springBootVersion = <span class="string">'2.0.3.RELEASE'</span></span><br><span class="line">&#125;</span><br><span class="line">repositories &#123;</span><br><span class="line">mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line">dependencies &#123;</span><br><span class="line">classpath(<span class="string">"org.springframework.boot:spring-boot-gradle-plugin:$&#123;springBootVersion&#125;"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">apply plugin: <span class="string">'java'</span></span><br><span class="line">apply plugin: <span class="string">'org.springframework.boot'</span></span><br><span class="line">apply plugin: <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"></span><br><span class="line">group = <span class="string">'com.example'</span></span><br><span class="line">version = <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">sourceCompatibility = <span class="number">1.8</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line"><span class="comment">//mavenCentral()</span></span><br><span class="line"><span class="comment">//使用淘宝的maven镜像</span></span><br><span class="line">    maven&#123; url <span class="string">'http://maven.aliyun.com/nexus/content/groups/public'</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-data-jpa'</span>)</span><br><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-web'</span>)</span><br><span class="line">testCompile(<span class="string">'org.springframework.boot:spring-boot-starter-test'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.项目目录结构大概如下<br><img src="http://po70nxvk4.bkt.clouddn.com/springboot-project.png" alt=""></p><p>5.设计代码分层结构<br>/src/main/java/com/ngame中设计如下分层结构：</p><ul><li>controller：控制层，接口类</li><li>dao：数据持久层代码</li><li>entity：javabean类，实体类</li><li>properites：读取<code>/application.yml</code>的配置类</li><li>service：业务逻辑代码</li><li>utils：工具类</li></ul><h2 id="4-数据库设计"><a href="#4-数据库设计" class="headerlink" title="4 数据库设计"></a>4 数据库设计</h2><p>都说设计Web最核心的是要把数据库设计好，确实是这样。<br>在上面环境搭建中我们已经安装好了mysql环境，可以通过Navicat来创建一个数据库<br>后端Java持久层，采用SpringBoot自带的<code>Spring Data JPA</code>，它是<code>Hibernate</code>作为ORM的实现，提供的API用来操作实体对象，执行CRUD操作，框架在后台替代我们完成所有的事情，开发者从繁琐的JDBC和SQL代码中解脱出来。</p><p>在后端项目中新建一个文件<code>./src/resources/application.yml</code>,配置数据库的相关参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:<span class="comment">//127.0.0.1:3306/qtm</span></span><br><span class="line">    username: root</span><br><span class="line">    password: <span class="number">123456</span></span><br><span class="line">  jpa:</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update</span><br><span class="line">    show-sql: <span class="keyword">true</span></span><br></pre></td></tr></table></figure></p><p>ps：以上参数的值请结合你实际的设置的情况来配置</p><p>确保项目中<code>build.gradle</code>中添加了jpa依赖，如果没有添加记得设置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(<span class="string">'org.springframework.boot:spring-boot-starter-data-jpa'</span>)</span><br></pre></td></tr></table></figure></p><p><strong>这里以自己的做的为例，用其中一个表作为示例。</strong><br>1.通过Navicat登录对应的数据库，创建一个表<code>table_info</code>,表结构如下：<br><img src="http://po70nxvk4.bkt.clouddn.com/mysql.png" alt=""><br>根据表结构在工程Entity层下创建一个对应的javabean类TableInfo，成员方法记得添加相应的注解<code>@Id</code>，<code>@GeneratedValue</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Id</span></span><br><span class="line"><span class="meta">@GeneratedValue</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> seen;</span><br><span class="line"><span class="keyword">private</span> Long rversion;     <span class="comment">//版本号</span></span><br><span class="line"><span class="keyword">private</span> String author;  <span class="comment">//提交人</span></span><br><span class="line"><span class="keyword">private</span> String message; <span class="comment">//log信息</span></span><br><span class="line"><span class="keyword">private</span> String  paths;  <span class="comment">//提交路径</span></span><br><span class="line"><span class="keyword">private</span> String dateTime; <span class="comment">//提交时间</span></span><br><span class="line"><span class="keyword">private</span> String personInCharge; <span class="comment">//负责人</span></span><br><span class="line"><span class="keyword">private</span> String submitType;   <span class="comment">//提交类型</span></span><br><span class="line"><span class="keyword">private</span> String influence;   <span class="comment">//影响面</span></span><br></pre></td></tr></table></figure></p><p>2.在工程Dao层创建对应的数据库表操作接口TableInfoDao，编写对应的数据库操作方法，非常方便不用写一句sql语句，简单到令人发指！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TableInfoDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">TableInfo</span> ,<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过id来查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TableInfo <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过reversion查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TableInfo <span class="title">findByRversion</span><span class="params">(Long rversion)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过dateTime查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TableInfo&gt; <span class="title">findByDateTimeBetween</span><span class="params">(String beginDate, String endDate)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ps：spring-data-jpa所有的语法规定如下图：<br><img src="http://po70nxvk4.bkt.clouddn.com/jpa.png" alt=""></p><p>然后在项目中就可以通过TableInfoDao接口实时操作数据库了</p><h2 id="5-设计springboot-restful风格的API"><a href="#5-设计springboot-restful风格的API" class="headerlink" title="5 设计springboot-restful风格的API"></a>5 设计springboot-restful风格的API</h2><p>关于restful API概念我就不详细介绍了，大家自行上网查看。<br>常用的HTTP操作有下面五个（括号里是对应的SQL命令）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET（SELECT）：从服务器取出资源（一项或多项）。</span><br><span class="line">POST（CREATE）：在服务器新建一个资源。</span><br><span class="line">PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</span><br><span class="line">PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</span><br><span class="line">DELETE（DELETE）：从服务器删除资源。</span><br></pre></td></tr></table></figure></p><p><strong>SpringBoot 对 REST 的支持实现</strong><br>举个API设计的栗子，<code>SVNMontiorController.java</code> Controller 实现 Restful HTTP 服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SVNMontiorController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SVNMontiorService svnMontiorService;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/api/svn/&#123;id&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TableInfo <span class="title">findTableInfo</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> svnMontiorService.findTableInfoById(id);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/api/svn"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TableInfo&gt; <span class="title">findAllTableInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> svnMontiorService.findAllTableInfo();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/api/svn"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTableInfo</span><span class="params">(@RequestBody TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        svnMontiorService.saveTableInfo(tableInfo);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/api/svn"</span>, method = RequestMethod.PUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyTableInfo</span><span class="params">(@RequestBody TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">        svnMontiorService.updateTableInfo(tableInfo);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/api/svn/&#123;id&#125;"</span>, method = RequestMethod.DELETE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyTableInfo</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        svnMontiorService.deleteTableInfo(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代码详解：<br>@RequestMapping 处理请求地址映射。</p><blockquote><p>method - 指定请求的方法类型：POST/GET/DELETE/PUT 等<br>value - 指定实际的请求地址<br>consumes - 指定处理请求的提交内容类型，例如 Content-Type 头部设置application/json, text/html<br>produces - 指定返回的内容类型</p></blockquote><p>@PathVariable URL 映射时，用于绑定请求参数到方法参数<br>@RequestBody 这里注解用于读取请求体 boy 的数据，通过 HttpMessageConverter 解析绑定到对象中</p><p>具体 Service 、Dao 层实现代码，由于篇幅原因就不贴出来了。</p><h2 id="6-前端-Mock-amp-API-调用"><a href="#6-前端-Mock-amp-API-调用" class="headerlink" title="6. 前端 Mock &amp; API 调用"></a>6. 前端 Mock &amp; API 调用</h2><h3 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h3><p>由于前后端分离后，前端和后台同时开发时，就可能遇到前端已经开发好一个页面了，可是却等待后端API接口的情况。</p><p>这种情况，怎么办呢？在我们这个项目里，我们是通过了mock来提供一些假数据，我们先规定好了API接口，设计出了一套API文档，然后我们就可以通过API文档，利用<a href="http://mockjs.com" title="Mock" target="_blank" rel="noopener">Mock</a>来返回一些假数据，因此前端也不需要依赖于后端开发了，可以独立开发，等到后台的API全部设计完之后，就可以比较快速的联调。</p><p>首先导入<code>mock</code>模块依赖<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'mockjs'</span></span><br></pre></td></tr></table></figure></p><p>然后对所要调用的API模拟数据，例如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Mock.mock(<span class="regexp">/getTableData/</span>, &#123;</span><br><span class="line">    <span class="string">"total"</span>: <span class="number">25</span>,</span><br><span class="line">    <span class="string">"list|25"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"orderId"</span>: <span class="string">"@id"</span>,</span><br><span class="line">        <span class="string">"product"</span>: <span class="string">"@ctitle(4)"</span>,</span><br><span class="line">        <span class="string">"version"</span>: <span class="string">"@ctitle(3)"</span>,</span><br><span class="line">        <span class="string">"period"</span>: <span class="string">"@integer(1,5)年"</span>,</span><br><span class="line">        <span class="string">"buyNum"</span>: <span class="string">"@integer(1,8)"</span>,</span><br><span class="line">        <span class="string">"date"</span>: <span class="string">"@date()"</span>,</span><br><span class="line">        <span class="string">"amount"</span>: <span class="string">"@integer(100, 500)元"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h3><p>在前端项目中通过Vuejs编写业务逻辑和静态界面，当需要与后端交互时，通过后端提供的API获取后端数据，举个例子：</p><table><thead><tr><th>api</th><th>localhost:8080/api/svn</th></tr></thead><tbody><tr><td>请求方式</td><td>GET</td></tr><tr><td>返回值</td><td>成功返回成功信息，失败返回失败原因</td></tr></tbody></table><p>通过<code>axios</code>组件调用API获取后端的数据，首先导入axios模块依赖<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br></pre></td></tr></table></figure></p><p>然后在业务代码中编写对应的axios逻辑获取后端数据<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> getSvnLog()&#123;</span><br><span class="line">  <span class="keyword">this</span>.$http.get(host + <span class="string">'/api/svn'</span>, &#123;</span><br><span class="line">params: &#123;</span><br><span class="line">  baseline: <span class="keyword">this</span>.formInline.baseline,</span><br><span class="line">  beginDate: <span class="keyword">this</span>.formInline.beginDate,</span><br><span class="line">  endDate: <span class="keyword">this</span>.formInline.endDate,</span><br><span class="line">&#125;</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">var</span> reponseData = response.data</span><br><span class="line"><span class="keyword">if</span> (reponseData.code == <span class="number">200</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>.tableData = reponseData.data</span><br><span class="line">  <span class="keyword">this</span>.loading = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$message.error(<span class="string">'错了哦，Form内容不能为空'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="7-打包部署"><a href="#7-打包部署" class="headerlink" title="7. 打包部署"></a>7. 打包部署</h2><h3 id="a-前端部署"><a href="#a-前端部署" class="headerlink" title="a 前端部署"></a>a 前端部署</h3><p><strong>nginx作为前端静态服务器：</strong></p><ul><li>当用户访问网站的时候，将index.html以及其引入的js、css、fonts以及图片返回给用户</li><li>负责将客户端发来的axios请求转发给后端服务器</li></ul><ol><li><p>执行如下命令，构建前端代码，构建成功后会在目录dist下生成构建完成的文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure></li><li><p>进入ngix目录/usr/local/nginx/conf，修改<code>nginx.conf</code>文件，将root参数路径指向你的构建文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">       listen       <span class="number">80</span>;</span><br><span class="line">       server_name  localhost;</span><br><span class="line">       root   /data/home/charlichen/qtm/client/dist;</span><br><span class="line">       index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">       #charset koi8-r;</span><br><span class="line"></span><br><span class="line">       #access_log  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">       #处理vue-router路径Start</span><br><span class="line">       #如果找不到路径则跳转到@router变量中寻找,找到了就默认进入index.html</span><br><span class="line">       location / &#123; </span><br><span class="line">           try_files $uri $uri/ /index.html last;</span><br><span class="line">           index  index.html index.htm;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>启动nginx，参考如下命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#启动Nginx</span><br><span class="line">start nginx  </span><br><span class="line">#快速停止或关闭Nginx</span><br><span class="line">nginx -s stop</span><br><span class="line">#正常停止或关闭Nginx</span><br><span class="line">nginx -s quit</span><br><span class="line">#配置文件修改重装载命令</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li></ol><h3 id="b-后端部署"><a href="#b-后端部署" class="headerlink" title="b 后端部署"></a>b 后端部署</h3><p>1.执行如下命令，构建完成后会在目录/build/lib下生成对应的jar包<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradle install</span><br><span class="line">gradle build</span><br></pre></td></tr></table></figure></p><p>2.执行<code>java -jar</code> 命令运行后端代码即可，当然如果你想永久运行，可以执行如下命令<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar name.jar &amp;</span><br></pre></td></tr></table></figure></p><p>3.此时会生成一个<code>nohup.out</code>文件，直接运行<code>tail -f nohup.out</code>命令，实时查看服务器log，当出现如下日志，表示服务器启动成功！<br><img src="http://thyrsi.com/t6/676/1551692318x2890202402.png" alt=""><br>当然打包前还有测试的环节，这里就不一一阐述了。</p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><p>以上通过web工程环境搭建，框架设计，数据库设计，restful API设计，前端调用API，打包部署，总结了一个web前后端分离工程的基本实现过程。在这个基础上，你便可以开始开发对应的前后端业务需求了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;导语 本文系笔者的工作笔记，根据目前比较流行的前后端分离思想，前后端独立开发独立部署互不影响原则，打造最有效率的web平台。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://po70nxvk4.bkt.clou
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="springboot, vue" scheme="http://yoursite.com/tags/springboot-vue/"/>
    
  </entry>
  
  <entry>
    <title>NLP文本相似度实践</title>
    <link href="http://yoursite.com/2018/05/01/NLP%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2018/05/01/NLP文本相似度实践/</id>
    <published>2018-05-01T14:36:25.000Z</published>
    <updated>2019-03-11T09:05:17.148Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>导语 AI在2018年应该是互联网界最火的名词，没有之一。时间来到了9102年，也是项目相关，涉及到了一些AI写作相关的功能。但是，AI并不一定最懂你，客户对于AI写出来的文章，多少是会做些修改的。为了更好的衡量出AI文章的可用度，在这儿就会需要存有一个反馈的环节，来看看用户润色后的文章与原始AI文章之间的区别是多大。 本文将从预备知识的概念开始介绍，从距离名词，到文本分词，相似度算法，并将这些概念融合、统一的介绍NLP中文本相似度的知识，期望通过本文，大家可以与我一样，对这些知识有个基本的了解。</p></blockquote><h2 id="几个距离"><a href="#几个距离" class="headerlink" title="几个距离"></a>几个距离</h2><p>在介绍更多的内容之前，我们需要了解文本距离的概念，这些距离是我们在后文比较文本相似度的基础，所以下面将首先形象的为大家介绍几个重要且基础的距离含义。</p><h2 id="欧几里德距离"><a href="#欧几里德距离" class="headerlink" title="欧几里德距离"></a>欧几里德距离</h2><p>Euclidean Distance，是最直白的、最容易直观理解的距离度量方法，在二维空间来看，用一句几乎耳熟能详的话来解释就是：两点之间直线最短。这句话中说到的「直线距离」就是欧几里德距离。我们来看下相关数学公式定义。</p><p>二维的公式：</p><p>p = sqrt( (x1-y1)^2+(x2-y2)^2 )</p><p>三维的公式：</p><p>p = sqrt( (x1-y1)^2+(x2-y2)^2+(x3-y3)^2 )</p><p>当然，毕竟不是存活于刘慈溪的三体世界之下，我们在小学或者日常所能感知到的多是，二维或者三维空间的距离，当大于3维，从数学理论上的n维空间的公式，在欧几里德空间中，点x =(x1,…,xn)和 y =(y1,…,yn)之间的欧氏距离为：</p><p>p = sqrt( (x1-y1)^2+(x2-y2)^2+(x3-y3)^2+ … +(xn-yn)^2 )</p><h2 id="曼哈顿距离"><a href="#曼哈顿距离" class="headerlink" title="曼哈顿距离"></a>曼哈顿距离</h2><p>Manhattan Distance的命名原因，是从规划为方型建筑区块的城市（如曼哈顿）间，最短的出租车从一个点A到另一个点B的行车路径距离，任何往东三区块、往北六区块的的路径一定最少要走九区块（出租车当然不能穿插过街区），没有其他捷径。抽象到数学角度，从点A(x1, y1)到点B(x2, y2)的曼哈顿距离为两个点上在标准坐标系上的绝对轴距之总和：</p><p>p = |x1-x2| + |y1-y2|</p><p>那么，曼哈顿距离和欧几里得距离的区别是什么呢？我们从维基百科拉过来一张图，就可以很直白的看到这二者的区别，假设在下方棋盘一样的图示中，白色方块表示为建筑物，灰色线条表示为道路，那么其中绿色线路表示为黑色两点之间的欧几里德距离（两点之间直线最短），而剩下的红蓝黄三色线路表示的均为为曼哈顿距离：<br><img src="http://po70nxvk4.bkt.clouddn.com/manhadun.png" alt="在这里插入图片描述"></p><h2 id="切比雪夫距离"><a href="#切比雪夫距离" class="headerlink" title="切比雪夫距离"></a>切比雪夫距离</h2><p>Chebyshev distance得名自俄罗斯数学家切比雪夫。大家对切比雪夫应该多少是觉得有印象的，没错，切比雪夫更被我们熟悉的是中学时候学过的关于他的切比雪夫多项式吧。所谓切比雪夫距离，是将两点之间的距离定义为其各座标数值差的最大值。如果我们以二维空间中两点A(x1,y1)和B(x2,y2)二点为例，其切比雪夫距离：</p><p>p = max(|x2-x1|, |y2-y1|)</p><p>更形象的来介绍，切比雪夫距离在二维空间有着一个应用场景：国际象棋中「国王」的行走距离。由于王可以往斜前或斜后方向移动一格，因此可以较有效率的到达目的的格子，我们将国际象棋的棋盘映射到二维直角座标系中，格子的边长定义为1，座标的x轴及y轴和棋盘方格平行，原点恰落在某一格的中心点，则「国王」从一个位置走到其他位置需要的步数恰为这两个位置的切比雪夫距离。下图是棋盘上所有位置距f6位置的切比雪夫距离。<br><img src="http://po70nxvk4.bkt.clouddn.com/qiebixuefu.png" alt="在这里插入图片描述"></p><h2 id="余弦距离"><a href="#余弦距离" class="headerlink" title="余弦距离"></a>余弦距离</h2><p>Cosine distance使用两个向量夹角的余弦值作为衡量两个个体间差异的大小。相比于欧几里德距离，余弦距离更加注重的是两个向量在方向上的差异。首先我们来看一下数学中余弦定理的定义：<br><img src="http://po70nxvk4.bkt.clouddn.com/yuxian4.png" alt="在这里插入图片描述"></p><p>关于余弦定理，这儿我们简单来复习下这个初中概念。前几年曾经有过一个地方的高考题出过余弦定理的证明，当时也有人通过向量的方法来证明，两行就得出了答案（其实这儿有点疑问，因为课本中对向量内积是通过余弦定理来证明的，所以从个人来看通过向量内积来证明余弦定理是有些逻辑问题的），那么具体应该如何证明呢？其实很简单，通过一张图就可以证明：<br><img src="http://po70nxvk4.bkt.clouddn.com/yuxian2.png" alt="在这里插入图片描述"></p><p>结合这张图，花2分钟应该就可以得到余弦定理的结论了，其中需要了解的一点事对于b*sin(θ)的定义，是直接使用了毕氏定理。</p><p>数学家已经证明，余弦的这种计算方法对n维向量也成立。假定A和B是两个n维向量，A是 [A1, A2, …, An] ，B是 [B1, B2, …, Bn] ，则A与B的夹角θ的余弦等于：<br><img src="http://po70nxvk4.bkt.clouddn.com/yuxian3.png" alt="在这里插入图片描述"><br>使用这个公式，我们会可以更方便的计算余弦距离。</p><p>回到余弦距离上来，它与我们上面说的欧几里得距离的区别是什么呢？我们引用一张网上的图片来形象的了解下余弦距离的含义：<br><img src="http://po70nxvk4.bkt.clouddn.com/yuxian4.png" alt="在这里插入图片描述"><br>在上图中，欧几里德距离dist(A, B)衡量的是空间中两点的绝对距离，跟各个点所在的位置坐标是直接相关的；而余弦距离衡量的是空间向量的夹角，更加体现在方向上的差异，而不是位置。如果我们保持A点位置不变，B点朝原方向远离坐标轴原点，那么这个时候余弦距离是保持不变的（因为夹角没有发生变化），而A、B两点的欧几里德距离显然在发生改变，这就是两者之间的不同之处。</p><p>关于余弦距离和欧几里得距离在现实场景中的区别，我们可以通过下面这个例子来形象的了解。现在有用户A和用户B分别对外卖骑手员工X和员工Y进行了评分。用户A对员工X的评分为2，对员工Y的评分为3，表示到坐标系中为坐标点AB(2, 3)；同样用户B对员工X、Y的评分表示为坐标点B(4, 6)，因此他们之间的欧几里德距离为：</p><p>p = sqrt((2 - 4)^2 + (3- 6)^2) = 3.6</p><p>而他们的余弦距离为：</p><p>p = (2 <em> 4 + 3 </em> 6) / ( sqrt( 2^2 + 3^2 ) * sqrt( 4^2 + 6^2 ) ) = 1</p><p>结合图示如下，其中，点A与点B之间的之间距离为红色线段所示，也就是上述的欧几里得距离。同时，线段0A和线段0B由于斜度相等，也就是夹角为0度，反映出的余弦距离就是cos(0) = 1，说明二者完全相似。</p><p>欧几里得距离和余弦距离各自有不同的计算方式和衡量特征，因此它们适用于不同的数据分析模型：前者能够体现个体数值特征的绝对差异，所以更多的用于需要从维度的数值大小中体现差异的分析，如使用用户行为指标分析用户价值的相似度或差异。后者则倾向于是从方向上区分差异，而对绝对的数值不敏感，更多的用于使用用户对内容评分来区分兴趣的相似度和差异，同时修正了用户间可能存在的度量标准不统一的问题（因为余弦距离对绝对数值不敏感）。</p><h2 id="汉明距离"><a href="#汉明距离" class="headerlink" title="汉明距离"></a>汉明距离</h2><p>Hamming distance在信息论中，表示为两个「等长」字符串之间对应位置的不同字符的个数。换句话说，汉明距离就是将一个字符串变换成另外一个字符串所需要「替换」的字符个数。如下图所示：</p><p>0110与1110之间的汉明距离是1；<br>0100与1001之间的汉明距离是3；<br><img src="http://po70nxvk4.bkt.clouddn.com/hanming.png" alt="在这里插入图片描述"></p><h2 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h2><p>在了解了上述一系列的距离含义之后，我们已经基本了解了衡量相似度的一个判定方法，但是对于一段文本内容来说，我们对什么来计算距离呢？这就涉及到了第二个基础知识：分词。</p><h4 id="分词方法"><a href="#分词方法" class="headerlink" title="分词方法"></a>分词方法</h4><p>为了实现对文本相似度的比较，我们需要分析文本的内容，也就必然会涉及到对文本进行分词处理。而说到分词，其中涉及的内容不比任何一个其他知识点要少，考虑到不是本文重点讲述，此处仅仅简单的列举了下当前分词算法的几种方向，有兴趣的同学可以就此列表再去细细琢磨</p><p>基于词表的分词方法<br>正向最大匹配法(forward maximum matching method, FMM)<br>逆向最大匹配法(backward maximum matching method, BMM)<br>N-最短路径方法<br>基于统计模型的分词方法<br>基于N-gram语言模型的分词方法<br>基于序列标注的分词方法<br>基于HMM的分词方法<br>基于CRF的分词方法<br>基于词感知机的分词方法<br>基于深度学习的端到端的分词方法</p><h2 id="文本相似度"><a href="#文本相似度" class="headerlink" title="文本相似度"></a>文本相似度</h2><p>在介绍完距离和分词之后，接下来，我们就需要来关注计算文本相似度的算法了。总的来说，计算文本相似度的算法共分为4类：</p><p>基于词向量<br>基于具体字符<br>基于概率统计<br>基于词嵌入的</p><p>结合我们上文的几种距离，其中欧几里德距离、曼哈顿距离和余弦距离等适合应用于词向量，汉明距离应属于基于字符的文本相似度的度量方法。本文接下来将重点介绍基于余弦复杂度的文本相似度比较算法，和适用于海量数据的simhash文本相似度算法，并给予一定的工程实现方案。</p><h4 id="余弦复杂度"><a href="#余弦复杂度" class="headerlink" title="余弦复杂度"></a>余弦复杂度</h4><p>对于多个不同的文本或者短文本对话消息要来计算他们之间的相似度如何，一个好的做法就是将这些文本中词语，映射到向量空间，形成文本中文字和向量数据的映射关系，再通过计算几个或者多个不同的向量的差异的大小，来计算文本的相似度。下面介绍一个详细成熟的向量空间余弦相似度方法计算相似度算法。</p><p>原理</p><p>枯燥的原理不如示例来的简单明了，我们将以一个简单的示例来介绍余弦复杂度的原理。现在有下面这样的两句话，从我们直觉感官来看，说的是一模一样的内容，那么我们通过计算其余弦距离来看看其相似度究竟为多少。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S1: &quot;为什么我的眼里常含泪水，因为我对这片土地爱得深沉&quot;</span><br><span class="line">S2: &quot;我深沉的爱着这片土地，所以我的眼里常含泪水&quot;</span><br></pre></td></tr></table></figure><p>第一步，分词：</p><p>我们对上述两段话分词分词并得到下面的词向量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S1: [为什么 我 的 眼里 常含 泪水 因为 我 对 这片 土地 爱得 深沉 ，]</span><br><span class="line">S2: [我 深沉 的 爱 着 这片 土地 所以 我 的 眼里 常含 泪水 ，]</span><br></pre></td></tr></table></figure><p>第二步，统计所有词组：</p><p>将S1和S2中出现的所有不同词组融合起来，并得到一个词向量超集，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[眼里 这片 为什么 我 的 常含 因为 对 所以 爱得 深沉 爱 着 ， 泪水 土地]</span><br></pre></td></tr></table></figure><p>第三步，获取词频：</p><p>对应上述的超级词向量，我们分别就S1的分词和S2的分词计算其出现频次，并记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S1: [1 1 1 2 1 1 1 1 0 1 1 0 0 1 1 1]</span><br><span class="line">S2: [1 1 0 2 2 1 0 0 1 0 1 1 1 1 1 1]</span><br></pre></td></tr></table></figure><p>第四步，复杂度计算：</p><p>通过上述的准备工作，现在我们可以想象在空间中存在着两条线段：SA和SB，二者均从原点（[0, 0, …]）出发，指向不同的方向，并分别终结于点A [1 1 1 2 1 1 1 1 0 1 1 0 0 1 1 1]和点B[1 1 0 2 2 1 0 0 1 0 1 1 1 1 1 1]，其中点A和点B的坐标与我们上述的词频一致。到了这一步，我们可以发现，对于句子S1和S2的相似度问题，已经被我们抽象到如何计算上述两个向量的相似问题了。</p><p>通过上文介绍的余弦定理，我们知道当两条线段之间形成一个夹角，如果夹角为0度，意味着方向相同、线段重合，我们就认定这是表示两个向量代表的文本完全相等；如果夹角为90度，意味着形成直角，方向完全不相似。因此，我们可以通过夹角的大小，来判断向量的相似程度。夹角越小，就代表越相似。</p><p>那么对于上述给定的两个属性向量A 和B，其余弦相似性θ由点积和向量长度给出，其余弦相似度的计算如下所示：<br><img src="http://po70nxvk4.bkt.clouddn.com/fuzadujisuan.png" alt="在这里插入图片描述"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>下面我们将通过golang来实现一个简单的余弦相似度算法（完整的代码在附件中）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">func CosineSimilar(srcWords, dstWords []string) float64 &#123;</span><br><span class="line">   // get all words</span><br><span class="line">   allWordsMap := make(map[string]int, 0)</span><br><span class="line">   for _, word := range srcWords &#123;</span><br><span class="line">      if _, found := allWordsMap[word]; !found &#123;</span><br><span class="line">         allWordsMap[word] = 1</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         allWordsMap[word] += 1</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for _, word := range dstWords &#123;</span><br><span class="line">      if _, found := allWordsMap[word]; !found &#123;</span><br><span class="line">         allWordsMap[word] = 1</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         allWordsMap[word] += 1</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // stable the sort</span><br><span class="line">   allWordsSlice := make([]string, 0)</span><br><span class="line">   for word, _ := range allWordsMap &#123;</span><br><span class="line">      allWordsSlice = append(allWordsSlice, word)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // assemble vector</span><br><span class="line">   srcVector := make([]int, len(allWordsSlice))</span><br><span class="line">   dstVector := make([]int, len(allWordsSlice))</span><br><span class="line">   for _, word := range srcWords &#123;</span><br><span class="line">      if index := indexOfSclie(allWordsSlice, word); index != -1 &#123;</span><br><span class="line">         srcVector[index] += 1</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   for _, word := range dstWords &#123;</span><br><span class="line">      if index := indexOfSclie(allWordsSlice, word); index != -1 &#123;</span><br><span class="line">         dstVector[index] += 1</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // calc cos</span><br><span class="line">   numerator := float64(0)</span><br><span class="line">   srcSq := 0</span><br><span class="line">   dstSq := 0</span><br><span class="line">   for i, srcCount := range srcVector &#123;</span><br><span class="line">      dstCount := dstVector[i]</span><br><span class="line">      numerator += float64(srcCount * dstCount)</span><br><span class="line">      srcSq += srcCount * srcCount</span><br><span class="line">      dstSq += dstCount * dstCount</span><br><span class="line">   &#125;</span><br><span class="line">   denominator := math.Sqrt(float64(srcSq * dstSq))</span><br><span class="line"></span><br><span class="line">   return numerator / denominator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>— PASS: TestCosineSimilar (0.84s)</p><p>similarity_test.go:23: CosineSimilar score: 0.7660323462854266</p><p>我们看到，对于上述两句话，在经过余弦计算后，得到的相似度为0.766（其夹角大概是40度），还是比较接近于1，所以，上面的句子S1和句子S2是基本相似的。由此，我们就得到了文本相似度计算的处理流程是:</p><p>1找出两篇文章的关键词；<br>2每篇文章各取出若干个关键词，合并成一个集合，计算每篇文章对于这个集合中的词的词频；<br>3生成两篇文章各自的词频向量；<br>4计算两个向量的余弦相似度，值越接近于1就表示越相似；</p><h4 id="simhash"><a href="#simhash" class="headerlink" title="simhash"></a>simhash</h4><p>基于余弦复杂度，通过两两比较文本向量来得到两个文本的相似程度是一个非常简单的算法。然而两两比较也就说明了时间复杂度是O(n2)，那么在面对互联网海量信息时，考虑到一个文章的特征向量词可能特别多导致整个向量维度很高，使得计算的代价太大，就有些力不从心了。因此，为了在爬取网页时用于快速去重，Google发明了一种快速衡量两个文本集相似度的算法：simhash。</p><p>简单来说，simhash中使用了一种局部敏感型的hash算法。所谓局部敏感性hash，与传统hash算法不同的是（如MD5，当原始文本越是相似，其hash数值差异越大），simhash中的hash对于越是相似的内容产生的签名越相近。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>simhash的主要思想是降维，将文本分词结果从一个高维向量映射成一个0和1组成的bit指纹(fingerprint)，然后通过比较这个二进制数字串的差异进而来表示原始文本内容的差异。下面我们通过图文方式来解释下这个降维和差异计算的过程。<br><img src="http://po70nxvk4.bkt.clouddn.com/yuanli.pngg" alt="在这里插入图片描述"><br>在simhash中处理一个文本的步骤如下：</p><p>第一步，分词：</p><p>对文本进行分词操作，同时需要我们同时返回当前词组在文本内容中的权重（这基本上是目前所有分词工具都支持的功能）。</p><p>第二步，计算hash：</p><p>对于每一个得到的词组做hash，将词语表示为到01表示的bit位，需要保证每个hash结果的位数相同，如图中所示，使用的是8bit。</p><p>第三步，加权</p><p>根据每个词组对应的权重，对hash值做加权计算（bit为1则取为1做乘积，bit为0则取为-1做乘积），如上图中，<br>10011111与权重2加权得到[2 -2 -2 2 2 2 2 2]；<br>01001011与权重1加权得到[-1 1 -1 -1 1 -1 1 1]；<br>01001011与权重4加权后得到[-4 4 -4 -4 4 -4 4 4]；</p><p>第三步，纵向相加：</p><p>将上述得到的加权向量结果，进行纵向相加实现降维，如上述所示，得到[-3 3 -7 -3 7 -3 7 7]。</p><p>第四步，归一化：</p><p>将最终降维向量，对于每一位大于0则取为1，否则取为0，这样就能得到最终的simhash的指纹签名[0 1 0 0 1 0 1 1]</p><p>第五步，相似度比较：</p><p>通过上面的步骤，我们可以利用SimHash算法为每一个网页生成一个向量指纹，在simhash中，判断2篇文本的相似性使用的是海明距离。什么是汉明距离？前文已经介绍过了。在在经验数据上，我们多认为两个文本的汉明距离&lt;=3的话则认定是相似的。</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">func SimHashSimilar(srcWordWeighs, dstWordWeights []WordWeight) (distance int, err error) &#123;</span><br><span class="line"></span><br><span class="line">   srcFingerPrint, err := simhashFingerPrint(srcWordWeighs)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      return</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(&quot;srcFingerPrint: &quot;, srcFingerPrint)</span><br><span class="line">   dstFingerPrint, err := simhashFingerPrint(dstWordWeights)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      return</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(&quot;dstFingerPrint: &quot;, dstFingerPrint)</span><br><span class="line"></span><br><span class="line">   distance = hammingDistance(srcFingerPrint, dstFingerPrint)</span><br><span class="line"></span><br><span class="line">   return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func simhashFingerPrint(wordWeights []WordWeight) (fingerPrint []string, err error) &#123;</span><br><span class="line">   binaryWeights := make([]float64, 32)</span><br><span class="line">   for _, ww := range wordWeights &#123;</span><br><span class="line">      bitHash := strHashBitCode(ww.Word)</span><br><span class="line">      weights := calcWithWeight(bitHash, ww.Weight) //binary每个元素与weight的乘积结果数组</span><br><span class="line">      binaryWeights, err = sliceInnerPlus(binaryWeights, weights)</span><br><span class="line">      //fmt.Printf(&quot;ww.Word:%v, bitHash:%v, ww.Weight:%v, binaryWeights: %v\n&quot;, ww.Word,bitHash, ww.Weight, binaryWeights)</span><br><span class="line">      if err != nil &#123;</span><br><span class="line">         return</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   fingerPrint = make([]string, 0)</span><br><span class="line">   for _, b := range binaryWeights &#123;</span><br><span class="line">      if b &gt; 0 &#123; // bit 1</span><br><span class="line">         fingerPrint = append(fingerPrint, &quot;1&quot;)</span><br><span class="line">      &#125; else &#123; // bit 0</span><br><span class="line">         fingerPrint = append(fingerPrint, &quot;0&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func calcWithWeight(bitHash string, weight float64) []float64 &#123;</span><br><span class="line">   bitHashs := strings.Split(bitHash, &quot;&quot;)</span><br><span class="line">   binarys := make([]float64, 0)</span><br><span class="line"></span><br><span class="line">   for _, bit := range bitHashs &#123;</span><br><span class="line">      if bit == &quot;0&quot; &#123;</span><br><span class="line">         binarys = append(binarys, float64(-1)*weight)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         binarys = append(binarys, float64(weight))</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return binarys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p>我们使用了调换一段长本文的语序来测试simhash的效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">文本1：</span><br><span class="line">&quot;沉默螺旋模式中呈现出民意动力的来源在于人类有害怕孤立的弱点，但光害怕孤立不至于影响民意的形成，&quot; +</span><br><span class="line">&quot;主要是当个人觉察到自己对某论题的意见与环境中的强势意见一致（或不一致时），害怕孤立这个变项才会产生作用。&quot; +</span><br><span class="line">&quot;从心理学的范畴来看，社会中的强势意见越来越强，甚至比实际情形还强，弱势意见越来越弱，甚至比实际情形还弱，这种动力运作的过程成–螺旋状&quot;</span><br><span class="line"></span><br><span class="line">文本2：</span><br><span class="line">&quot;从心理学的范畴来看，害怕孤立这个变项才会产生作用。社会中的强势意见越来越强，甚至比实际情形还强，弱势意见越来越弱，&quot; +</span><br><span class="line">&quot;主要是当个人觉察到自己对某论题的意见与环境中的强势意见一致（或不一致时），甚至比实际情形还弱，这种动力运作的过程成–螺旋状&quot; +</span><br><span class="line">&quot;但光害怕孤立不至于影响民意的形成，沉默螺旋模式中呈现出民意动力的来源在于人类有害怕孤立的弱点&quot;</span><br></pre></td></tr></table></figure><p>通过计算，结果得到二者的指纹是一模一样，其汉明距离为0.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">srcFingerPrint:  [1 0 0 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 0 1 1 1 0 0 0 0 0 0]</span><br><span class="line">dstFingerPrint:  [1 0 0 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 0 1 0 0 0 1 1 1 0 0 0 0 0 0]</span><br><span class="line">--- PASS: TestSimHashSimilar (0.85s)</span><br><span class="line">    similarity_test.go:57: SimHashSimilar distance: 0</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><h4 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h4><p>注意一：</p><p>我们再来看一个文章主旨类似，但是内容相关性较低的文本比较示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">文本1：</span><br><span class="line">&quot;关于区块链和数字货币的关系，很多人或多或少都存在疑惑。简单来说，区块链是比特币的底层运用，而比特币只是区块链的一个小应用而已。&quot; +</span><br><span class="line">&quot;数字货币即虚拟货币，最早的数字货币诞生于2009年，其发明者中本聪为了应对经济危机对于实体货币经济的冲击。比特币是最早的数字货币，后来出现了以太币、火币以及莱特币等虚拟货币，这些虚拟货币是不能用来交易的。&quot; +</span><br><span class="line">&quot;狭义来讲，区块链是一种按照时间顺序将数据区块以顺序相连的方式组合成的一种链式数据结构， 并以密码学方式保证的不可篡改和不可伪造的分布式账本。&quot; +</span><br><span class="line">&quot;广义来讲，区块链技术是利用块链式数据结构来验证与存储数据、利用分布式节点共识算法来生成和更新数据、利用密码学的方式保证数据传输和访问的安全、利用由自动化脚本代码组成的智能合约来编程和操作数据的一种全新的分布式基础架构与计算方式。&quot;</span><br><span class="line"></span><br><span class="line">文本2：</span><br><span class="line">&quot;区块链技术为我们的信息防伪与数据追踪提供了革新手段。区块链中的数据区块顺序相连构成了一个不可篡改的数据链条，时间戳为所有的交易行为贴上了一套不讲课伪造的真是标签，这对于人们在现实生活中打击假冒伪劣产品大有裨益； &quot; +</span><br><span class="line">&quot;市场分析指出，整体而言，区块链技术目前在十大金融领域显示出应用前景，分别是资产证券化、保险、供应链金融、场外市场、资产托管、大宗商品交易、风险信息共享机制、贸易融资、银团贷款、股权交易交割。&quot; +</span><br><span class="line">&quot;这些金融场景有三大共性：参与节点多、验真成本高、交易流程长，而区块链的分布式记账、不可篡改、内置合约等特性可以为这些金融业务中的痛点提供解决方案。&quot; +</span><br><span class="line">&quot;传统的工业互联网模式是由一个中心化的机构收集和管理所有的数据信息，容易产生因设备生命周期和安全等方面的缺陷引起的数据丢失、篡改等问题。区块链技术可以在无需任何信任单个节点的同时构建整个网络的信任共识，从而很好的解决目前工业互联网技术领域的一些缺陷，让物与物之间能够实现更好的连接。&quot;</span><br></pre></td></tr></table></figure><p>通过计算，当我们选择前top10高频词作为衡量时，结果得到二者的指纹是如下，其汉明距离为4：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">srcFingerPrint:  [1 0 1 1 0 1 0 0 0 1 1 1 1 1 1 0 1 0 0 1 0 1 1 1 0 0 0 1 0 0 0 1]</span><br><span class="line">dstFingerPrint:  [1 0 1 1 0 1 0 0 0 1 1 1 1 1 1 0 1 1 0 1 1 1 1 0 0 0 0 1 0 1 0 1]</span><br><span class="line">--- PASS: TestSimHashSimilar (0.84s)</span><br><span class="line">    similarity_test.go:58: SimHashSimilar distance: 4</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>当我们选择前top50高频词作为衡量时，结果得到二者的指纹是如下，其汉明距离为9：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">srcFingerPrint:  [1 0 1 1 0 1 0 0 0 1 1 1 1 0 0 0 1 0 0 1 0 1 1 0 1 0 0 0 0 1 0 1]</span><br><span class="line">dstFingerPrint:  [1 0 1 1 0 1 0 1 0 0 1 0 1 1 0 0 1 1 0 1 1 1 1 0 0 0 0 1 0 0 0 1]</span><br><span class="line">--- PASS: TestSimHashSimilar (0.83s)</span><br><span class="line">    similarity_test.go:58: SimHashSimilar distance: 9</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>所以我们发现了一个对结果判定很重要的参数：分词数量。在上面的示例中，当我们选择10个分词时，其汉明距离仅为4，几乎符合了我们对文本相似（汉明距离3）的判断。而随着topN数量的增加，引入了更多的词组，其汉明距离越来越大，这也说明了，当大文本内容出现时，选择合适的topN分词数量进行比较对结果的影响是十分大的。</p><p>注意二：</p><p>另外一点需要需要注意的是，simhash的优点是适用于高维度的海量数据处理，当维度降低，如短文本的相似度比较，simhash并不合适，以我们计算余弦相似度的文本为例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S1: &quot;为什么我的眼里常含泪水，因为我对这片土地爱得深沉&quot;</span><br><span class="line">S2: &quot;我深沉的爱着这片土地，所以我的眼里常含泪水&quot;</span><br></pre></td></tr></table></figure><p>得到的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">srcFingerPrint:  [1 1 1 0 1 0 0 1 1 1 0 1 0 0 0 0 1 0 1 1 1 0 1 0 1 0 1 1 0 0 1 0]</span><br><span class="line">dstFingerPrint:  [1 0 1 0 0 0 1 1 0 1 1 0 1 0 0 1 0 0 0 1 1 0 1 1 1 1 1 1 0 0 1 0]</span><br><span class="line">--- PASS: TestSimHashSimilar (0.86s)</span><br><span class="line">    similarity_test.go:53: SimHashSimilar distance: 12</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure><p>也就是结果的汉明距离为12，远远大于我们预定的汉明距离3，这样的结果跟我们通过预先相似度计算出来的0.76分（相比于1分）相差很远，可见simhash对于短文本的相似度比较还是存在一些偏差的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://lujiaying.github.io/posts/2018/01/Chinese-word-segmentation/" target="_blank" rel="noopener">https://lujiaying.github.io/posts/2018/01/Chinese-word-segmentation/</a></p><p><a href="https://www.zhihu.com/question/19578687" target="_blank" rel="noopener">https://www.zhihu.com/question/19578687</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;导语 AI在2018年应该是互联网界最火的名词，没有之一。时间来到了9102年，也是项目相关，涉及到了一些AI写作相关的功能。但是，AI并不一定最懂你，客户对于AI写出来的文章，多少是会做些修改的。为了更好的衡量出AI文章的可用度，在这儿
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="AI, NLP" scheme="http://yoursite.com/tags/AI-NLP/"/>
    
  </entry>
  
  <entry>
    <title>关于持续集成的一点总结</title>
    <link href="http://yoursite.com/2018/01/06/%E5%85%B3%E4%BA%8E%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/06/关于持续集成的一点总结/</id>
    <published>2018-01-06T08:38:22.000Z</published>
    <updated>2019-03-05T10:29:15.568Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>前段时间，一直在做持续集成的工作，就将这段时间积攒的经验（踩过的坑）给大家分享下。</p></blockquote><h2 id="什么是持续集成"><a href="#什么是持续集成" class="headerlink" title="什么是持续集成"></a>什么是持续集成</h2><p>说到持续集成，我们好多同学不由自主地就想起了Jenkins等平台工具，前几年和老大一起推行持续集成还开发了一套系统。</p><p>其实这些工具也好、平台系统也好，都是为了持续集成能够正常运转服务的。那什么是持续集成呢？我们可以分开来看：</p><ul><li><strong>持续</strong>就是每完成一个完整的部分，就向下个环节交付，发现问题马上调整，不会放大到其他部分和后面的环节；</li><li><strong>集成</strong>就是软件个人研发的部分向软件整体部分交付，以便尽早发现个人开发部分的问题。<br><img src="http://thyrsi.com/t6/676/1551781125x2890202420.png" alt="在这里插入图片描述"><br>总而言之，<strong>持续集成本质是一种思想，一种工作方式，强调开发人员提交了新代码之后，立刻进行构建、测试，以保证新代码和原有代码能正确地集成在一起</strong>。我们在推行持续集成时，千万不要本末倒置了，这件事最核心是培养大家的意识和工作习惯，而不是去推行什么工具平台。</li></ul><h2 id="为什么要做持续集成"><a href="#为什么要做持续集成" class="headerlink" title="为什么要做持续集成"></a>为什么要做持续集成</h2><p>在软件工程里，有一个指标叫做质量成本，即项目出现质量问题的修复成本。下图是各个阶段软件质量成本的评估：<br><img src="http://thyrsi.com/t6/676/1551781185x2890202420.png" alt="在这里插入图片描述"><br>我们不难看出，随着时间的推移，质量成本以指数级趋势增加。所以我们做持续集成的根本目的就是为了尽可能早地发现、解决质量问题。</p><h2 id="怎么去做持续集成"><a href="#怎么去做持续集成" class="headerlink" title="怎么去做持续集成"></a>怎么去做持续集成</h2><p>我们可以先从什么是持续集成来分析都要做哪些工作，主要有以下三个方面：</p><ul><li>代码提交的监控</li><li>工程的构建以及测试的运行</li><li>结果的反馈以及推进修复</li></ul><p>再从为什么要做持续集成来分析如何做好这件事。为了保证质量问题能够尽早地被发现和解决，还是从上面的上三个方面来说。</p><h3 id="监控代码提交"><a href="#监控代码提交" class="headerlink" title="监控代码提交"></a>监控代码提交</h3><p>现在各种持续集成的平台都提供监控代码库的功能，我就不详细介绍了。这里我想强调的是有些同学并不会在完成一个完整部分时就将代码提交仓库，有些喜欢憋大招，一次性给你整个几百上千行代码。所以这里强调必须让开发同学及时提交代码。</p><p>那怎么去控制，方法有很多。目前我们这边是通过Code Review机制以及一些规范约束来规避的。引入Code Review后，为了尽快能过审，大家都会尽快提交，同时一次性提交太多代码Review的成本也会很大，所以开发自己就会定一些流程规范去约束。当然Code Review的好处还远不止这些，强烈推荐，非本文主题这里就不详述了。</p><h3 id="工程构建和测试的运行"><a href="#工程构建和测试的运行" class="headerlink" title="工程构建和测试的运行"></a>工程构建和测试的运行</h3><p>持续集成是为了让整个项目运转更加健康高效，如果因为跑持续集成而拖慢了进度那就得不偿失了。所以这里须要保证工程的构建和测试运行足够高效，时间没有固定标准，但按照我们以往的经验，最好不要超过5分钟。</p><p>这里可能同学要说我们项目的测试5分钟实在跑不完怎么办？没错，这是很常见的问题，我们也不可能在5分钟内跑完所有的测试。所以这里就涉及到一个测试用例的筛选，主要可以从下面两个思路来考虑：</p><ul><li>用例的重要性和出现问题的概率。将一部分非常重要路径和容易出问题的用例筛选出来，每次持续集成只跑这部分测试用例，这样能保证大部分问题都能及时被发现。</li><li>测试用例与提交代码的相关性。这个就是精准测试的思想，如果每次只跑与这次代码相关的测试用例是最好不过的。不过这个想做好也很难，因为相关性不好评估。现在大多数精准测试都是用代码覆盖率来做，不过这样一旦修改了底层代码，就有可能关联上所有用例，而且新代码的集成也可能会导致用例和代码的映射关系发生变化。</li></ul><p>综上，大家可以项目的需要和成本自己选择怎么去筛选测试用例，如果条件允许建议二者结合使用，同时建议定期（一般是每天）去跑全量的用例。</p><h3 id="结果的反馈以及推进修复"><a href="#结果的反馈以及推进修复" class="headerlink" title="结果的反馈以及推进修复"></a>结果的反馈以及推进修复</h3><p>最后就是检查结果，如果有问题及时推进修复。这是整个过程中最重要也是最难做的一个环节，首先必须要保证结果的准确性，然后得让开发同学有及时处理的意识。第二件事事建立在第一件的基础上，如果你的测试结果老是误报问题，开发自然就会不积极去响应甚至忽视持续集成的结果。</p><p>那么如何提高测试结果的准确率呢？主要有两个方面：</p><ul><li>测试代码的健壮性。当然健壮性不是指不管出现什么情况用例都能通过，那就没有意义了。这里是指对本用例测试点无关的点有足够好的健壮性。比如：测试输入法纠错算法的用例就不应该受到词库变动的影响。</li><li>测试用例的专一性。同理，测试用例的设计也要保证足够专一，每个用例对应一个测试点。否则一旦用例失败了，查问题都不好查。</li></ul><p>当然，我们的集成测试肯定还有要有的，这里的测试用例的设计就非常关键了，必须要保证非常强的合理性。比如还是输入法纠错，如果要测试整个流程没有问题，我们就必须选择一个非常合理的Case，就是这条用例不按照我们说的做就是有问题，哪怕是词库数据修改导致的也说明你们数据修改的不合理。</p><p>最后，结果的准确性还不止这些，除了不能误报问题，更不能漏报问题。误报了我们还可以花时间处理，漏报了那就是事故了。所以如何保证测试的覆盖度是我们工作的重中之重。这里集成级的测试还好，一般软件整体结构功能变化的还是比较少的，而且一旦有也是从结合需求，我们有足够的时间去补充修改用例。不过单元层次的就难说了，随时都有可能会增加或者修改函数，所以这一层测试建议最好由测试和开发同学一起来维护。</p><p>总而言之，需要让测试结果具有十足的意义，强化团队对系统的信心，这样问题的修复甚至都不用我们去推进了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>写了这么多，我完全没有提到任何测试工具和平台的使用，是这些都不重要吗？当然不是，只不过任何的平台和工具都是为解决问题服务的，只有想清楚了问题工具才能发挥最大的效果。反之亦然，想发挥出最好的效果具体工作还是要依靠各种平台工具，这也是为什么我懂了这么多，团队的持续集成还是一团烂摊子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;前段时间，一直在做持续集成的工作，就将这段时间积攒的经验（踩过的坑）给大家分享下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是持续集成&quot;&gt;&lt;a href=&quot;#什么是持续集成&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="持续集成" scheme="http://yoursite.com/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化来龙去脉总结</title>
    <link href="http://yoursite.com/2017/05/12/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9D%A5%E9%BE%99%E5%8E%BB%E8%84%89%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/05/12/Android性能优化来龙去脉总结/</id>
    <published>2017-05-12T10:10:38.000Z</published>
    <updated>2019-03-04T08:55:06.750Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>一款app除了要有令人惊叹的功能和令人发指交互之外，在性能上也应该追求丝滑的要求，这样才能更好地提高用户体验。</p></blockquote><p>以下是本人在工作中对经历过的性能优化的一些总结，依据故事的发展路线，将其分为了5个部分，分别是：常见的性能问题；产生性能问题的一些可能原因；解决性能问题的套路；代码建议及潜在性能问题排查项。<br><img src="http://thyrsi.com/t6/676/1551688683x2890203019.png" alt=""></p><h2 id="一、首先，我们先了解一下都有哪些性能问题"><a href="#一、首先，我们先了解一下都有哪些性能问题" class="headerlink" title="一、首先，我们先了解一下都有哪些性能问题"></a>一、首先，我们先了解一下都有哪些性能问题</h2><p><img src="http://thyrsi.com/t6/676/1551689182x2728309394.png" alt=""></p><h4 id="1、内存泄露"><a href="#1、内存泄露" class="headerlink" title="1、内存泄露"></a>1、内存泄露</h4><p>通俗来讲，内存泄露不仅仅会造成应用内存占用过大，还会导致应用卡顿，造成不好的用户体验，至于，为什么一个“小小的”内存泄露会造成应用卡顿，我不得不拿这幅图来说说话了。<br><img src="http://thyrsi.com/t6/676/1551689265x2728309394.png" alt=""><br>没错，这就是Android开发童鞋需要了解的Generational Heap Memory模型，这里我们只关心当对象在Young Generation中存活了一段时间之后，如果没被干掉，那么会被移动到Old Generation中。<strong>同理，最后会移动到Permanent Generation中（这里最后不会移动到Permanent Generation，Permanent Generation存放应用的类/方法信息, 以及JRE库的类和方法信息）</strong>。那么用脚想一想就知道，如果内存泄露了，那么，抱歉，你那块内存随时间推移自然而然将进入Old Generation中，然鹅，内存不是白菜，想要多少就有多少，这里，因为沙盒机制的原因，分配给你应用的内存当然是有那么一个极限值的，你不能逾越（有人笑了，不是有large heap么，当然我也笑了，我并没有看到这货被宗师android玩家青睐过），好了，你那块造成泄露内存的对象占着茅坑不拉屎，剩下来可以供其他对象发挥的内存空间就少了；打个比方，舞台小了，演员要登台表演，没有多余空间，他就只能等待其他演员下来他才能表演啊，这等待的时间，是没法连续表演的，所以就卡了嘛。</p><h4 id="2、频繁GC"><a href="#2、频繁GC" class="headerlink" title="2、频繁GC"></a>2、频繁GC</h4><p>呵呵，频繁GC会造成卡顿，想必你经过上面的洗礼，已经知道了为什么，不错，当然也是因为“舞台空间不足，新的演员上台表演需要先让表演完的下来”。那么造成这种现象的原因是什么呢？</p><p>a、内存泄露，好的，你懂了，不用讲了，这个必须有可能会造成。</p><p>b、大量对象短时间被创建，又在短时间内“需要”被释放，注意这里的需要，其实是不得不，为什么，同样是因为“舞台空间不够了”，举个例子，在onDraw中new 对象，因为onDraw大约16ms会执行一次（wait，你能否确定一下，什么是大约16ms，对不起，不能，掉帧了就不是，哪怕掉那么一点点）。脑补一下，每秒中创建大约60个对象，嗯，骚年，你以为Young Generation是白菜么，想拿多少就拿多少，对不起，这里是限量的，这里用完了，在来申请，我就得去回收一些回来，我回收总得耗时间吧，耗时间，好吧，onDraw 等着等着就错过了下一个16ms的执行了，如是，用户看起来就卡了。</p><h4 id="3、耗电问题"><a href="#3、耗电问题" class="headerlink" title="3、耗电问题"></a>3、耗电问题</h4><p>km上有一个问题很尖锐，说是微视看小视频看一会手机就会发烫，所以，用户一直就很关注耗电问题，不过不好意思，我们的app至今还没有遇到过严重的耗电问题，虽然没有遇到比较严重的耗电问题，不代表就不需要去了解这样的问题的解决办法，我总结有：</p><p>a、没有什么特别重要的信息，比如，钱到账，电话来了，100元实打实无门槛代金券方法，等等，请不要打扰用户，不要频繁唤醒用户，否则，结果只能是卸载，或者关闭一切通知。</p><p>b、适当的做本地缓存，避免频繁请求网络数据，这里，说起来容易，做起来并非三刀两斧就能搞定，要配合良好的缓存策略，区分哪些是一段时间不会变更的，哪些是绝对不能缓存的很重要。</p><p>c、对某些执行时间较长的同步操作在用户充电且有wifi的时候在做，除非用户强制同步..等等，就不扯太多，因为后面还有很多内容。</p><h4 id="4、OOM问题"><a href="#4、OOM问题" class="headerlink" title="4、OOM问题"></a>4、OOM问题</h4><p>呵呵，这个问题，想必经过前面1、2的洗礼，你应该已经明白这个什么原因导致的，你可以想想一下”舞台上将要上的一个演员是一个巨大胖子，即便不表演的演员都下来了，他还是挤不上去，怎么办，演砸了，还能怎么办，直接崩溃，散场！”造成这个问题的原因，可能有，（呵呵，保险起见，只能说可能，分析的时候可以从这里出发）</p><p>a、内存泄露了，想必你会心一笑。</p><p>b、大量不可见的对象占据内存，这个其实，很常见，只是大家可能一直不太关心罢了，比如，请求接口返回了列表有100项数据，每项数据比如有100个字段，其中你用户展示数据的只有10几个而已，但是，你解析的时候，剩下的99个不知不觉吃了你的内存，当，有个胖子要内存时，呵呵，嗝屁了。</p><p>c、还有一种很常见的场景是一个页面多图的场景，明明每个图只需要加载一个100<em>100的，你却使用原始尺寸（1080</em>1980）or更大，而且你一下子还加载个几十张，扛得住么？所以了解一下inSampleSize，或者，如果图片归你们上传管理，你可以借助万象优图，他为你做了剪切好不同尺寸的图片，这样省得你在客户端做图片缩放了。</p><h2 id="二、以上了解了一些性能问题，这里，简单的串一串导致这些性能问题的原因"><a href="#二、以上了解了一些性能问题，这里，简单的串一串导致这些性能问题的原因" class="headerlink" title="二、以上了解了一些性能问题，这里，简单的串一串导致这些性能问题的原因"></a>二、以上了解了一些性能问题，这里，简单的串一串导致这些性能问题的原因</h2><p><img src="http://thyrsi.com/t6/676/1551689298x2728309394.png" alt=""></p><h4 id="1、人为在ui线程中做了轻微的耗时操作，导致ui线程卡顿。"><a href="#1、人为在ui线程中做了轻微的耗时操作，导致ui线程卡顿。" class="headerlink" title="1、人为在ui线程中做了轻微的耗时操作，导致ui线程卡顿。"></a>1、人为在ui线程中做了轻微的耗时操作，导致ui线程卡顿。</h4><p>嗯，很多小伙伴不以为然，以为在onCreate中读一下pref算什么，解析下json数据算得了什么，可实际情况是并不是这样的，正确的做法是，将这些操作使用异步封装起来，小伙伴可以了解一下rxjava，现在最新版本已经是rxjava2了，如果不清楚使用方式，不要捉急，搜一下我的文章，《rxjava那些风骚的用法合辑》，如果没有包含你需要的用法，不要捉急，Google一下吧。</p><h4 id="2、layout过于复杂，无法在16ms完成渲染。"><a href="#2、layout过于复杂，无法在16ms完成渲染。" class="headerlink" title="2、layout过于复杂，无法在16ms完成渲染。"></a>2、layout过于复杂，无法在16ms完成渲染。</h4><p>这个很多小伙伴深有体会了，这里简单的了解下，我们先简单的把渲染大概分为”layout”,”measure””draw”这么几个阶段，当然你不要以为实际情况也是如此，好，层级复杂，layout,measure可能就用到了不该用的时间，自然而然，留给draw的时间就可能不够了，自然而然就悲剧了。那么以前给出的很多建议是，使用RelativeLayout替换LinearLayout,说是可以减少布局层次，然鹅，现在请不要在建议别人使用RelativeLayout，因为ConstraintLayout才是一个更高性能的消灭布局层级的神器。ConstraintLayout 基于Cassowary算法，而Cassowary算法的优势是在于解决线性方程时有极高的效率，事实证明，线性方程组是非常适合用于定义用户界面元素的参数。由于人们对图形的敏感度非常高，所以UI的渲染速度显得非常重要。因此在2016年，iOS和Android都基于Cassowary算法来研发了属于自己的布局系统，这里是ConstraintLayout与传统布局RelativeLayout，LinearLayout实现时的性能对比，不过这里是老外的测试数据，原文可以参考这里。demo中也提供了测试的方法，感兴趣的小伙伴可以尝试一下咯。</p><h4 id="3、同一时间执行的动画过多，导致CPU或者GPU负载过重。"><a href="#3、同一时间执行的动画过多，导致CPU或者GPU负载过重。" class="headerlink" title="3、同一时间执行的动画过多，导致CPU或者GPU负载过重。"></a>3、同一时间执行的动画过多，导致CPU或者GPU负载过重。</h4><p>这里主要是因为动画一般会频繁变更view的属性，导致displayList失效，而需要重新创建一个新的displayList，如果动画过多，这个开销可想而知，如果你想了解得更加详细，推荐看这篇咯，知识点在第5节那里。</p><h4 id="4、view过度绘制的问题。"><a href="#4、view过度绘制的问题。" class="headerlink" title="4、view过度绘制的问题。"></a>4、view过度绘制的问题。</h4><p>view过度绘制的问题可以说是我们在写布局的时候遇到的一个最常见的问题之一，可以说写着写着一不留神就写出了一个过度绘制，通常发生在一个嵌套的viewgroup中，比如你给他设置了一个不必要的背景。这方面问题的排查不太难，我们可以通过手机设置里面的开发者选项，打开Show GPU Overdraw的选项，轻松发现这些问题，然后尽量往蓝色靠近。</p><p><img src="http://thyrsi.com/t6/676/1551689360x2728309394.png" alt=""></p><h4 id="5、gc过多的问题，这里就不在赘述了，上面已经讲的非常直接了。"><a href="#5、gc过多的问题，这里就不在赘述了，上面已经讲的非常直接了。" class="headerlink" title="5、gc过多的问题，这里就不在赘述了，上面已经讲的非常直接了。"></a>5、gc过多的问题，这里就不在赘述了，上面已经讲的非常直接了。</h4><h4 id="6、资源加载导致执行缓慢。"><a href="#6、资源加载导致执行缓慢。" class="headerlink" title="6、资源加载导致执行缓慢。"></a>6、资源加载导致执行缓慢。</h4><p>有些时候避免不要加载一些资源，这里有两种解决的办法，使用的场景也不相同。</p><p>a、预加载，即还没有来到路径之前，就提前加载好，诶，好像x5内核就是酱紫哦。</p><p>b、实在是要等到用到的时候加载，请给一个进度条，不要让用户干等着，也不知道什么时候结束而造成不好的用户体验。</p><h4 id="7、工作线程优先级设置不对，导致和ui线程抢占cpu时间。"><a href="#7、工作线程优先级设置不对，导致和ui线程抢占cpu时间。" class="headerlink" title="7、工作线程优先级设置不对，导致和ui线程抢占cpu时间。"></a>7、工作线程优先级设置不对，导致和ui线程抢占cpu时间。</h4><p>使用Rxjava的小伙伴要注意这点，设置任务的执行线程可能会对你的性能产生较大的影响，没有使用的小伙伴也不能太过大意。</p><h4 id="8、静态变量。"><a href="#8、静态变量。" class="headerlink" title="8、静态变量。"></a>8、静态变量。</h4><p>嘿嘿，大家一定有过在application中设置静态变量的经历，遥想当年，为了越过Intent只能传递1M以下数据的坑，我在application中设置了一个静态变量，用于两个activity“传递（共享）数据”，然而，一步小心，数据中，有着前一个activity的尾巴，因此泄露了。不光是这样的例子，随便举几个：</p><p>a、你用静态集合保存过数据吧？</p><p>b、某某单例的Manger，比如管理AudioManger遇到过吧？</p><h2 id="三、既然遇到问题分析也有了，那么接下来，自然而然是如何使用各种刀棒棍剑来解决这些问题了"><a href="#三、既然遇到问题分析也有了，那么接下来，自然而然是如何使用各种刀棒棍剑来解决这些问题了" class="headerlink" title="三、既然遇到问题分析也有了，那么接下来，自然而然是如何使用各种刀棒棍剑来解决这些问题了"></a>三、既然遇到问题分析也有了，那么接下来，自然而然是如何使用各种刀棒棍剑来解决这些问题了</h2><p><img src="http://thyrsi.com/t6/676/1551689429x2728309394.png" alt=""></p><h4 id="1、GPU过度绘制，定位过度绘制区域"><a href="#1、GPU过度绘制，定位过度绘制区域" class="headerlink" title="1、GPU过度绘制，定位过度绘制区域"></a>1、GPU过度绘制，定位过度绘制区域</h4><p>这里直接在开发者选项，打开Show GPU Overdraw，就可以看到效果，轻松发现哪块需要优化，那么具体如何去优化</p><p>a、减少布局层级，上面有提到过，使用ConstraintLayout替换传统的布局方式。如果你对ConstraintLayout不了解，没有关系，这篇文章教你15分钟了解如何使用ConstraintLayout。</p><p>b、检查是否有多余的背景色设置，我们通常会犯一些低级错误–对被覆盖的父view设置背景，多数情况下这些背景是没有必要的。</p><h4 id="2、主线程耗时操作排查。"><a href="#2、主线程耗时操作排查。" class="headerlink" title="2、主线程耗时操作排查。"></a>2、主线程耗时操作排查。</h4><p>a、开启strictmode,这样一来，主线程的耗时操作都将以告警的形式呈现到logcat当中。</p><p>b、直接对怀疑的对象加@DebugLog，查看方法执行耗时。DebugLog注解需要引入插件hugo，这个是Android之神JakeWharton的早期作品，对于监控函数执行时间非常方便，直接在函数上加入注解就可以实现，但是有一个缺点，就是JakeWharton发布的最后一个版本没有支持release版本用空方法替代监控代码，因此，我这里发布了一个到公司的maven仓库，引用的方式和官网类似，只不过，地址是：’com.tencent.tip:hugo-plugin:2.0.0-SNAPSHOT’。</p><h4 id="3、对于measure，layout耗时过多的问题"><a href="#3、对于measure，layout耗时过多的问题" class="headerlink" title="3、对于measure，layout耗时过多的问题"></a>3、对于measure，layout耗时过多的问题</h4><p>一般这类问题是优于布局过于复杂的原因导致，现在因为有ConstraintLayout，所以，强烈建议使用ConstraintLayout减少布局层级，问题一般得以解决，如果发现还存在性能问题，可以使用traceView观察方法耗时，来定位下具体原因。</p><h4 id="4、leakcany"><a href="#4、leakcany" class="headerlink" title="4、leakcany"></a>4、leakcany</h4><p>这个是内存泄露监测的银弹，大家应该都使用过，需要提醒一下的是，要注意</p><pre><code>dependencies {    debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.5.4&apos;    releaseImplementation &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.5.4&apos;}</code></pre><p>引入方式，releaseImplementation保证在发布包中移除监控代码，否则，他自生不停的catch内存快照，本身也影响性能。</p><h4 id="5、onDraw里面写代码需要注意"><a href="#5、onDraw里面写代码需要注意" class="headerlink" title="5、onDraw里面写代码需要注意"></a>5、onDraw里面写代码需要注意</h4><p>onDraw优于大概每16ms都会被执行一次，因此本身就相当于一个forloop，如果你在里面new对象的话，不知不觉中就满足了短时间内大量对象创建并释放，于是频繁GC就发生了，嗯，内存抖动，于是，卡了。因此，正确的做法是将对象放在外面new出来。</p><h4 id="6、json反序列化问题"><a href="#6、json反序列化问题" class="headerlink" title="6、json反序列化问题"></a>6、json反序列化问题</h4><p>json反序列化是指将json字符串转变为对象，这里如果数据量比较多，特别是有相当多的string的时候，解析起来不仅耗时，而且还很吃内存。解决的方式是：</p><p>a、精简字段，与后台协商，相关接口剔除不必要的字段。保证最小可用原则。</p><p>b、使用流解析，之前我考虑过json解析优化，在Stack Overflow上搜索到这个。于是了解到Gson.fromJson是可以这样玩的，可以提升25%的解析效率。<br><img src="http://thyrsi.com/t6/676/1551689546x2728309394.png" alt=""></p><h4 id="7、viewStub-amp-merge的使用。"><a href="#7、viewStub-amp-merge的使用。" class="headerlink" title="7、viewStub&amp;merge的使用。"></a>7、viewStub&amp;merge的使用。</h4><p>这里merge和viewStub想必是大家非常了解的两个布局组件了，对于只有在某些条件下才展示出来的组件，建议使用viewStub包裹起来，同样的道理，include 某布局如果其根布局和引入他的父布局一致，建议使用merge包裹起来，如果你担心preview效果问题，这里完全没有必要，因为你可以</p><p>tools:showIn=””属性，这样就可以正常展示preview了。</p><h4 id="8、加载优化"><a href="#8、加载优化" class="headerlink" title="8、加载优化"></a>8、加载优化</h4><p>这里并没有过多的技术点在里面，无非就是将耗时的操作封装到异步中去了，但是，有一点不得不提的是，要注意多进程的问题，如果你的应用是多进程，你应该认识到你的application的oncreate方法会被执行多次，你一定不希望资源加载多次吧，于是你只在主进程加载，如是有些坑就出现了，有可能其他进程需要那某份资源，然后他这个进程缺没有加载相应的资源，然后就嗝屁了。</p><h4 id="9、刷新优化。"><a href="#9、刷新优化。" class="headerlink" title="9、刷新优化。"></a>9、刷新优化。</h4><p>这点在我之前的文章中有提到过，这里举两个例子吧。</p><p>a、对于列表的中的item的操作，比如对item点赞，此时不应该让整个列表刷新，而是应该只刷新这个item，相比对于熟练使用recyclerView的你，应该明白如何操作了,不懂请看这里，你将会明白什么叫做recyclerView的局部刷新。</p><p>b、对于较为复杂的页面，个人建议不要写在一个activity中，建议使用几个fragment进行组装，这样一来，module的变更可以只刷新某一个具体的fragment，而不用整个页面都走刷新逻辑。但是问题来了，fragment之间如何共享数据呢？好，看我怎么操作。<br><img src="http://thyrsi.com/t6/676/1551689598x2728309394.png" alt=""><br>Activity将数据这部分抽象成一个LiveData，交个LiveDataManger数据进行管理，然后各个Fragment通过Activity的这个context从LiveDataManger中拿到LiveData,进行操作，通知activity数据变更等等。哈哈，你没有看错，这个确实和Google的那个LiveData有点像，当然，如果你想使用Google的那个，也自然没问题，只不过，这个是简化版的。项目的引入</p><p>‘com.tencent.tip:simple_live_data:1.0.1-SNAPSHOT’</p><h4 id="10、动画优化"><a href="#10、动画优化" class="headerlink" title="10、动画优化"></a>10、动画优化</h4><p>这里主要是想说使用硬件加速来做优化，不过要注意，动画做完之后，关闭硬件加速，因为开启硬件加速本身就是一种消耗。下面有一幅图，第二幅对比第一幅是说开启硬件加速和没开启的时候做动画的效果对比，可以看到开启后的渲染速度明显快不少，开启硬件加速就一定万事大吉么？第三幅图实际上就说明，如果你的这个view不断的失效的话，也会出现性能问题，第三图中可以看到蓝色的部曲线图有了一定的起色，这说明，displaylist不断的失效并重现创建.</p><h4 id="11耗电优化"><a href="#11耗电优化" class="headerlink" title="11耗电优化"></a>11耗电优化</h4><p>这里仅仅只是建议；</p><p>a、在定位精度要求不高的情况下，使用wifi或移动网络进行定位，没有必要开启GPS定位。</p><p>b、先验证网络的可用性，在发送网络请求，比如，当用户处于2G状态下，而此时的操作是查看一张大图，下载下来可能都200多K甚至更大，我们没必要去发送这个请求，让用户一直等待那个菊花吧。</p><h2 id="四、接下来的一些内容就比较轻松了，是关于一些代码的建议"><a href="#四、接下来的一些内容就比较轻松了，是关于一些代码的建议" class="headerlink" title="四、接下来的一些内容就比较轻松了，是关于一些代码的建议"></a>四、接下来的一些内容就比较轻松了，是关于一些代码的建议</h2><p><img src="http://thyrsi.com/t6/676/1551689649x2728309394.png" alt=""><br>这里不一一细讲了，仅仅挑标记的部分说下。</p><p>pb-&gt;model这里的优化就不在赘述，前面有讲如何优化。</p><p>然后建议使用SparseArray代替HashMap,这里是Google建议的，因为SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱比如（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间。</p><p>不到不得已，不要使用wrap_content,,推荐使用match_parent,或者固定尺寸，配合gravity=”center”，哈哈，你应该懂了的。</p><p>那么为什么说这样会比较好。</p><p>因为 在测量过程中，match_parent和固定宽高度对应EXACTLY ,而wrap_content对应AT_MOST,这两者对比AT_MOST耗时较多。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>这是以上关于我在工作中遇到的性能问题的及处理的一些总结，性能优化涉及的方方面面实在是太多太多，本文并没有能够将全部的性能问题都清清楚楚的分析总结一下，文章或许还多多少少存在一些纰漏之处，有不对的地方欢迎指出补充，一起学习，一起进步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;一款app除了要有令人惊叹的功能和令人发指交互之外，在性能上也应该追求丝滑的要求，这样才能更好地提高用户体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是本人在工作中对经历过的性能优化的一些总结，依据故事的发展路线，将其分为了5个部
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android, 专项测试" scheme="http://yoursite.com/tags/Android-%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>彻底弄懂常见的中文字符编码</title>
    <link href="http://yoursite.com/2017/03/01/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <id>http://yoursite.com/2017/03/01/彻底弄懂常见的中文字符编码/</id>
    <published>2017-03-01T04:20:15.000Z</published>
    <updated>2019-03-05T10:29:40.950Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>本文主要介绍了业务中常见的ASCII、GB2312、GBK、GB18030、UTF8、ANSI、Latin1中文编码。如果你在业务中也曾经被乱码搞晕过，不妨我们一起探究一下。</p></blockquote><p>最近我的业务中涉及到了包含中文文本的内容解析。业务场景是用户上传一个包含中文的文本文件，我们需要根据约定好的字段格式解析该文本，并将内容导入到数据库中。但用户所传上来的文件中文编码经常会不一样，于是我们的数据库中经常会有乱码出现。为了解决该问题，就有了这篇文章……</p><h2 id="一、字符编码要做什么事情？"><a href="#一、字符编码要做什么事情？" class="headerlink" title="一、字符编码要做什么事情？"></a>一、字符编码要做什么事情？</h2><p>在计算机眼里读到的所有文字都是由0和1组成的字符串，为了能让汉字正常显示在屏幕上，我们需要做以下两件事情：<br>【1】给所有的汉字一个独一无二的数字编号，做一个数字编号到汉字的mapping关系（即字符集）<br>【2】把这个数字编号能用0和1表示出来<br>这里需要说明的是，第【2】件事情并不是直接把数字编号用二进制表示出来那么简单，还要处理多个字连在一起的时候如何做分隔的问题。例如如果我把”腾”编为1号（二进制00000001，占1byte），把“讯”编为5号（二进制00000101，占1byte），汉字这么多，一定还有一个汉字被编为了261号（二进制00000001 00000101，占2bytes）。那么现在问题来了，当计算机读到00000001 00000101这一串的时候，它应该显示“腾讯”两个字还是显示那一个261号的文字？因此如何做分隔也是字符编码需要考虑的事情。</p><p>第【2】件事情通常解决方案要么就是规定好每个字长度（例如所有文字都是2bytes，不够的前面用0补齐），要么就是在用0和1表示的时候，不仅需要表示出数字编码，还要暗示给计算机接下来多少个连续byte构成一个字，这个后面UTF8编码中会提到。</p><p>我们通常所说的Unicode，其实只做了第【1】件事情，并且是给全世界所有语言的所有文字或字母一个独一无二的数字编码，这样只要设计一种机制做第【2】件事情来表示Unicode，就可以显示全球范围内任何文字了。Unicode具体对所有语言的每个字母、文字的数字编号可以从其官方网站<a href="http://www.unicode.org/charts/" target="_blank" rel="noopener">http://www.unicode.org/charts/</a> 查询。该官网一大亮点是，中文编码表的体量远远超过其他任何语言……</p><p>（为了让文章易懂，我们暂时舍弃一些晦涩概念。晦涩地讲，现代字符编码模型其实分5个层次，可以参考链接了解：<a href="http://www.unicode.org/reports/tr17/" target="_blank" rel="noopener">http://www.unicode.org/reports/tr17/</a> ，不在我们讨论范围内了）</p><h2 id="二、几种常见中文编码的关系如何？"><a href="#二、几种常见中文编码的关系如何？" class="headerlink" title="二、几种常见中文编码的关系如何？"></a>二、几种常见中文编码的关系如何？</h2><p>几种常见中文编码之间存在兼容性，一图胜千言<br><img src="http://thyrsi.com/t6/676/1551687214x2890202498.png" alt="几种中文编码的兼容性"><br>所谓兼容性可以简单理解为子集，同时存在也不冲突，不会出现上文所说的不知道是“腾讯”还是261号文字的情况。图中我们可以看出，ASCII被所有编码兼容，而最常见的UTF8与GBK之间除了ASCII部分之外没有交集，这也是平时业务中最常见的导致乱码场景，使用UTF8去读取GBK编码的文字，可能会看到各种乱码。而GB系列的几种编码，GB18030兼容GBK，GBK又兼容GB2312，下文细讲。</p><h2 id="三、ASCII编码"><a href="#三、ASCII编码" class="headerlink" title="三、ASCII编码"></a>三、ASCII编码</h2><p>ASCII编码每个字母或符号占1byte（8bits），并且8bits的最高位是0，因此ASCII能编码的字母和符号只有128个。有一些编码把8bits最高位为1的后128个值也编码上，使得1byte可以表示256个值，但是这属于扩展的ASCII，并非标准ASCII。通常所说的标准ASCII只有前128个值！ASCII编码几乎被世界上所有编码所兼容（UTF16和UTF32是个例外），因此如果一个文本文档里面的内容全都由ASCII里面的字母或符号构成，那么不管你如何展示该文档的内容，都不可能出现乱码的情况。<br><img src="http://thyrsi.com/t6/676/1551687310x2890202498.jpg" alt=" ASCII编码表"></p><h2 id="四、GB2312、GBK、GB18030编码"><a href="#四、GB2312、GBK、GB18030编码" class="headerlink" title="四、GB2312、GBK、GB18030编码"></a>四、GB2312、GBK、GB18030编码</h2><p>GB全称GuoBiao国标，GBK全称GuoBiaoKuozhan国标扩展。GB18030编码兼容GBK，GBK兼容GB2312，其实这三种编码有着非常深厚的渊源，我们放在一起进行比较。</p><p>【GB2312】最早一版的中文编码，每个字占据2bytes。由于要和ASCII兼容，那这2bytes最高位不可以为0了（否则和ASCII会有冲突）。在GB2312中收录了6763个汉字以及682个特殊符号，已经囊括了生活中最常用的所有汉字。（GB2312编码全表：<a href="http://tools.jb51.net/table/gb2312" target="_blank" rel="noopener">http://tools.jb51.net/table/gb2312</a> ）</p><p>GB2312编码表有个值得注意的点，这个表中也有一些数字和字母，与ASCII里面的字母非常像。例如A3B2对应的是数字2（如下图），但是ASCII里面50（十进制）对应的也是数字2。他们的区别就是输入法中所说的“半角”和“全角”。全角的数字2占两个字节。通常，我们在打字或编程中都使用半角，即ASCII来编写数字或英文字母。特别是编程中，如果写全角的数字或字母，编译器很有可能不认识……<br><img src="http://thyrsi.com/t6/676/1551687349x2890202498.png" alt="GB2312与ASCII重合的部分字符"></p><p>【GBK】由于GB2312只有6763个汉字，我汉语博大精深，只有6763个字怎么够？于是GBK中在保证不和GB2312、ASCII冲突（即兼容GB2312和ASCII）的前提下，也用每个字占据2bytes的方式又编码了许多汉字。经过GBK编码后，可以表示的汉字达到了20902个，另有984个汉语标点符号、部首等。值得注意的是这20902个汉字还包含了繁体字，但是该繁体字与台湾Big5编码不兼容，因为同一个繁体字很可能在GBK和Big5中数字编码是不一样的。（GBK编码全表：<a href="http://tools.jb51.net/table/gbk_table" target="_blank" rel="noopener">http://tools.jb51.net/table/gbk_table</a> ）</p><p>【GB18030】然而，GBK的两万多字也已经无法满足我们的需求了，还有更多可能你自己从来没见过的汉字需要编码。这时候显然只用2bytes表示一个字已经不够用了（2bytes最多只有65536种组合，然而为了和ASCII兼容，最高位不能为0就已经直接淘汰了一半的组合，只剩下3万多种组合无法满足全部汉字要求）。因此GB18030多出来的汉字使用4bytes编码。当然，为了兼容GBK，这个四字节的前两位显然不能与GBK冲突（实操中发现后两位也并没有和GBK冲突）。我国在2000年和2005年分别颁布的两次GB18030编码，其中2005年的是在2000年基础上进一步补充。至此，GB18030编码的中文文件已经有七万多个汉字了，甚至包含了少数民族文字。（本人搜寻了好久，GB18030已经没有online编码全表了，只找到了我国发布该编码时候的官方文书，放在本文附件中，大家感兴趣可以下载下来开开眼……）</p><p>GB2312，GBK，GB18030都是采取了固定长度的办法来解决字符分隔（即前文所提的第【2】件事情）问题。GBK和GB2312比ASCII多出来的字都是2bytes，GB18030比GBK多出来的字都是4bytes。至于他们具体是如何做到兼容的，可以参考下图：<br><img src="http://thyrsi.com/t6/676/1551687396x2890202498.png" alt="几种不同编码的前2字节值域"></p><p>这图中展示了前文所述的几种编码在编码完成后，前2个byte的值域（用16进制表示）。每个byte可以表示00到FF（即0至255）。ASCII编码由于是单字节，所以没有第2位。因为GBK兼容GB2312，所以理论上上图中GB2312的领土面积也可以算在GBK的范围内，GB18030也同理。上图只是展示出了比之前编码“多”出来的面积。GB18030由于是4bytes编码，上图只是展示了前2bytes的值域，虽然面积最小，但是如果后2bytes也算上，GB18030新编码的字数实际上远远多于GBK。<br>可以看出为了做到兼容性，以上所有编码的前2bytes做到了相互值域不冲突，这样就可以允许几种不同编码中的文字同时出现在同一个文本文件中。只要全都按照GB18030编码的规则去解析并展示文件，就不会有乱码出现。实际业务中GB18030很少提到，通常GBK见得比较多，这是因为如果你去看一下GB18030里面所编码的文字，你会发现自己一个字也不认识……<br><img src="http://thyrsi.com/t6/676/1551687445x2890202498.png" alt="GB18030编码的部分汉字"></p><h2 id="五、UTF8编码-Unicode-Transformation-Format"><a href="#五、UTF8编码-Unicode-Transformation-Format" class="headerlink" title="五、UTF8编码(Unicode Transformation Format)"></a>五、UTF8编码(Unicode Transformation Format)</h2><p>99%的前端写网页时都会加上<meta charset="utf-8">，99%的后端工程师新建数据库表时都会加上DEFAULT CHARSET=utf8（剩下的1%应该是忘了写）。之所以我们想让UTF8一统天下，就是因为UTF8可以表示出世界上所有的文字！UTF8与前面说的GB系列编码不兼容，所以如果一个文件中即有UTF8编码的文字，又有GB18030编码的文字，那绝对会有乱码。</p><p>Unicode赋予了全世界所有文字和符号一个独一无二的数字编号，UTF8所做的事情就是把这个数字编号表示出来（即解决前文提到的第【2】件事情）。UTF8解决字符间分隔的方式是数二进制中最高位连续1的个数来决定这个字是几字节编码。0开头的属于单字节，和ASCII码重合，做到了兼容。</p><p>以三字节为例，开头第一个字节的”1110”，有连续三个1，说明包括本字节在内，接下来三个字节一起构成了一个文字。凡是不属于文字首字节的byte都以“10”开头，上表中标注X的位置才是真正用来表示Unicode数值的。这种巧妙设计，把Unicode的数值和每个字的字节数融合在一起，最坏情况是6个字节表示一个字，已经足够表示世界上所有语言的所有文字了。不过从这种表示方式也可以很显然地看出来，UTF8和GBK没有任何关系，除了都兼容ASCII以外。</p><p><img src="http://thyrsi.com/t6/676/1551687476x2890202498.png" alt="&quot;鹅&quot;字的UTF8编码计算过程"></p><h2 id="六、其他经常遇到的编码"><a href="#六、其他经常遇到的编码" class="headerlink" title="六、其他经常遇到的编码"></a>六、其他经常遇到的编码</h2><p>ANSI编码</p><p>准确说，并不存在哪种具体的编码方式叫做ANSI，它只是一个Windows操作系统上的别称而已。在中文简体Windows操作系统上，ANSI就是GBK；在泰语操作系统上，ANSI就是TIS-620（一种泰语编码）；在韩语操作系统上，ANSI就是EUC-KR（一种韩语编码）。并且所谓的ANSI只存在于Windows操作系统上。</p><p>Latin1编码（又名ISO-8859-1编码）</p><p>相信99%的人第一次听到Latin1都是在使用Mysql数据库的时候接触到的。Latin1是Mysql数据库表的默认编码方式。Latin1也是单字节编码方式，也就是说最多只能表示256个字母或符号，并且前128个和ASCII完全吻合。Latin1在ASCII基础上又充分利用了后面那128个值，赋予他们一些泰语、希腊语等字母或符号，将1个字节的256个值全部占满了。因为项目中用不到，我们对这种编码的细节没兴趣了解，唯一感兴趣的是为什么Mysql选它做默认编码（为什么默认编码不是UTF8）？以及如果忘了设置Mysql表的编码方式时，用Latin1存储中文会不会出问题？<br><img src="http://thyrsi.com/t6/676/1551687720x2890202498.png" alt="Latin1编码表"></p><p>为什么默认编码是Latin1而不是UTF8？主要原因是Latin1为单字节编码，并且将1个字节的所有256个值全部占满，因此理论上把任何编码的值塞到Latin1字段都是可以存的（无非就是显示乱码而已）。假设默认为UTF8这一多字节编码，在用户误把一个不使用UTF8编码的字符串存进去时，很有可能因为该字符串不符合UTF8的编码要求导致Mysql根本没法处理。这也是单字节编码的一大好处：显示可以乱码，但是里面的数据值永远正确。</p><p>用Latin1存储中文有没有问题？首先用Latin1存储中文没有问题，但是并不建议。例如你把UTF8编码的“讯”字（UTF8编码为0xE8AEAF，占三个字节）存入了Latin1编码的Mysql表，那么在Mysql眼里，你存入的并不是一个“讯”字，而是三个Latin1的字母（0xE8，0xAE，0xAF）。本质上，你存的数据值依然是0xE8AEAF，这种“欺骗”Mysql的行为并没有导致数据丢失，只不过你需要注意读取出来该值的时候，自己要以UTF8编码的方式显示出来，要不然就是乱码。因此，用Latin1存任何文字技术上都可以，但是经常会导致数据显示乱码。通常的解决方案，就是让UTF8一统天下，建表的时候就声明charset为utf8。</p><p>文章最后，遗留一个问题。既然有这么多编码形式，如果给定一个文本文件，不告诉你是什么编码，如何用程序进行检测？比较有代表性的编码检测库为python的chardet，其具体的原理，且待下回分解~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要介绍了业务中常见的ASCII、GB2312、GBK、GB18030、UTF8、ANSI、Latin1中文编码。如果你在业务中也曾经被乱码搞晕过，不妨我们一起探究一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近我的业务中涉及到
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Smartphone--Android真机管理平台</title>
    <link href="http://yoursite.com/2017/02/10/Smartphone--Android%E7%9C%9F%E6%9C%BA%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0/"/>
    <id>http://yoursite.com/2017/02/10/Smartphone--Android真机管理平台/</id>
    <published>2017-02-10T12:32:30.000Z</published>
    <updated>2018-05-01T12:28:22.997Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h2><p>最近在工作中发现几个问题：</p><ul><li>作为测试人员，在做产品兼容性测试时，发现手上的测试设备总是不够用，但是可能其他同事的设备在闲置着；</li><li>作为Android和H5开发人员，如果测试同事发现一个兼容性的bug，要想还原场景，还要把测试设备给开发（如果不在一个楼层，还要来回跑）</li><li>作为产品和运营人员，为了体验产品，也要去申请测试设备，但是大部分时间，设备是闲置的。</li></ul><p>在这样一个背景下，我在想有没有一个平台，可以把整个公司的线下Android测试设备，通过Web端进行线上远程管理控制，类似于模拟器（当然它是真机），在你的本地电脑进行操作，这样不仅能充分利用测试设备，而且还节省公司购买测试设备的开支。<br>基于这个理念，我大量查阅google，baidu，发现真的老外已经开发好了这样一个平台，而且还开源啦。<br>官方主页：<a href="https://openstf.github.io/" target="_blank" rel="noopener">https://openstf.github.io/</a><br>github地址：<a href="https://github.com/openstf/stf" target="_blank" rel="noopener">https://github.com/openstf/stf</a> </p><p><strong>该平台可以把整个公司的线下Android设备集合在一起，通过Web端进行线上远程管理控制，在你的本地电脑进行操作，不仅提高测试设备的利用率，还节省公司购买测试设备的开支。</strong></p><p>展示下官网的效果图：<br><img src="http://img.blog.csdn.net/20161010155531455" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20161009235629811" alt="这里写图片描述"></p><hr><h2 id="平台优点："><a href="#平台优点：" class="headerlink" title="平台优点："></a>平台优点：</h2><ul><li>大大提高线下设备的利用率，节省公司购买测试设备的开支</li><li>线下真机能做的，它都可以做，包括在线拍照，截图</li><li>可以进行远程调试</li></ul><h2 id="适用人群："><a href="#适用人群：" class="headerlink" title="适用人群："></a>适用人群：</h2><p>测试工程师<br>                  Android工程师          （真机调试）<br>                  前端H5开发工程师  （真机调试）<br>                  产品和运营               （产品体验）</p><hr><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a><strong>环境搭建</strong></h2><p>由于本人的办公电脑是Mac，现在就基于Mac OS X系统搭建环境（Linux环境和Windows环境应该类似）</p><h3 id="1-JDK和Android-SDK环境安装"><a href="#1-JDK和Android-SDK环境安装" class="headerlink" title="1. JDK和Android SDK环境安装"></a>1. JDK和Android SDK环境安装</h3><p>JDK下载：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>SDK下载：<a href="https://developer.android.com/studio/index.html" target="_blank" rel="noopener">https://developer.android.com/studio/index.html</a></p><p>配置环境变量并保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home </span><br><span class="line">export ANDROID_HOME=/Users/CharlieChen/Library/Android/sdk</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$ANDROID_HOME/platform-tools:$ANDROID_HOME/tools</span><br></pre></td></tr></table></figure><h3 id="2-nodejs安装"><a href="#2-nodejs安装" class="headerlink" title="2. nodejs安装"></a>2. nodejs安装</h3><p>因为该平台是通过nodejs语言写的，所以必须安装nodejs的运行环境。<br>在<a href="https://nodejs.org/download/" target="_blank" rel="noopener">https://nodejs.org/download/</a> 下载nodejs安装包，解压并控制台进入目录安装</p><h3 id="2-安装Bower"><a href="#2-安装Bower" class="headerlink" title="2. 安装Bower"></a>2. 安装Bower</h3><p>控制台执行npm命令进行Bower安装并等待完成<br>npm install bower -g<br>验证安装是否成功：bower -v  如果可以显示版本号 证明成功</p><h3 id="3-安装RethinkDB"><a href="#3-安装RethinkDB" class="headerlink" title="3. 安装RethinkDB"></a>3. 安装RethinkDB</h3><p>rethinkDB为平台的数据库，存储的用户和设备的信息，可能大家只对Mysql 或mangoDB熟悉，但这没关系，先安装再说，至于原理后面有时间再去了解。<br>先下载rethinkdb安装包：<a href="http://download.rethinkdb.com/osx/" target="_blank" rel="noopener">http://download.rethinkdb.com/osx/</a><br>双击rethinkdb-2.0.4.dmg  安装.pkg包即可<br> 验证安装是否成功：rethinkdb -version  如果可以显示版本号 证明成功</p><h3 id="4-安装GraphicsMagick"><a href="#4-安装GraphicsMagick" class="headerlink" title="4. 安装GraphicsMagick"></a>4. 安装GraphicsMagick</h3><p>brew install graphicsmagick</p><p>如果发现brew命令不可用，说明你的电脑没有装brew的环境，装一下就可以啦</p><h3 id="5-安装libsodium-zeromq的依赖"><a href="#5-安装libsodium-zeromq的依赖" class="headerlink" title="5. 安装libsodium(zeromq的依赖)"></a>5. 安装libsodium(zeromq的依赖)</h3><p> brew install libsodium</p><h3 id="6-安装zeromq"><a href="#6-安装zeromq" class="headerlink" title="6. 安装zeromq"></a>6. 安装zeromq</h3><p>brew install zmq</p><h3 id="7-安装protobuf"><a href="#7-安装protobuf" class="headerlink" title="7. 安装protobuf"></a>7. 安装protobuf</h3><p>brew install protobuf</p><h3 id="8-安装pkg-config"><a href="#8-安装pkg-config" class="headerlink" title="8. 安装pkg-config"></a>8. 安装pkg-config</h3><p>brew install pkgconfig</p><p>修改环境变量：<br>添加如下信息：<br>export PATH=$PATH:/usr/local/Cellar/protobuf/2.6.1/bin/   （请以本地下载路径为准）<br>export PKG_CONFIG_PATH=/usr/local/Cellar/protobuf/2.6.1/lib/pkgconfig/     （请以本地下载路径为准）</p><h3 id="9-安装stf"><a href="#9-安装stf" class="headerlink" title="9. 安装stf"></a>9. 安装stf</h3><p>sudo npm install -g stf</p><hr><h2 id="Smartphone服务端运行"><a href="#Smartphone服务端运行" class="headerlink" title="Smartphone服务端运行"></a><strong>Smartphone服务端运行</strong></h2><h3 id="1-启动rethinkDB"><a href="#1-启动rethinkDB" class="headerlink" title="1. 启动rethinkDB"></a>1. 启动rethinkDB</h3><p>安装完成后，打开单独的控制台，运行命令等待服务启动完成：<br>rethinkdb<br><img src="http://img.blog.csdn.net/20161010162215350" alt="这里写图片描述"></p><h3 id="2-启动stf服务端"><a href="#2-启动stf服务端" class="headerlink" title="2. 启动stf服务端"></a>2. 启动stf服务端</h3><p>打开一个单独的控制台，运行命令等待服务启动完成：<br>stf local<br>如果要远程登录平台的话，需要增加本地服务器的ip地址<br>stf local –public-ip 本机IP<br><img src="http://img.blog.csdn.net/20161010162232350" alt="这里写图片描述"></p><hr><h2 id="Smartphone客户端运行"><a href="#Smartphone客户端运行" class="headerlink" title="Smartphone客户端运行"></a><strong>Smartphone客户端运行</strong></h2><p>在浏览器中输入地址：http://本机ip:7100/ 访问客户端。<br>输入用户名和邮箱登录即可开始使用。<br>登录界面：<br><img src="http://img.blog.csdn.net/20161010163424241" alt="这里写图片描述"></p><p>设备列表界面：<br><img src="http://img.blog.csdn.net/20161010163813800" alt="这里写图片描述"></p><p>设备使用界面：<br><img src="http://img.blog.csdn.net/20161010163925223" alt="这里写图片描述"></p><hr><h2 id="Smartphone二次改造"><a href="#Smartphone二次改造" class="headerlink" title="Smartphone二次改造"></a><strong>Smartphone二次改造</strong></h2><p>你可以根据公司的需求，进行Smartphone平台的二次开发。可能大家发现了我的平台登录界面换成了我公司的logo，设备使用界面，增加了shell脚本和远程调试等等。。<br>这个就不一一讲了，后面有时间再设一个专题详细讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;&lt;strong&gt;背景&lt;/strong
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="专项测试" scheme="http://yoursite.com/tags/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android稳定性测试-- Monkey二次开发</title>
    <link href="http://yoursite.com/2017/01/01/Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%B5%8B%E8%AF%95--%20Monkey%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2017/01/01/Android稳定性测试-- Monkey二次开发/</id>
    <published>2017-01-01T05:41:52.000Z</published>
    <updated>2018-05-01T12:25:47.950Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>前面一遍blog <a href="http://blog.csdn.net/tobetheender/article/details/53448949" target="_blank" rel="noopener">Monkey源码分析</a>讲到Monkey的代码结构和代码执行流程，相信通过介绍大家应该对monkey的运行原理和核心逻辑有了很深刻的了解。我们做的这一切都是为了更好的了解monkey的内部逻辑进行二次开发。<br>为什么要二次开发前面的文章也大概说了，它毕竟是一款为稳定性测试而准备的小工具，所以存在很多局限性：</p><ul><li>Monkey不提供<strong>截屏功能</strong>，因此测试很难找到问题复现的场景；</li><li>Monkey无法进行<strong>控件识别</strong>，对事件流控制能力很微弱；</li><li>执行过程中容易误点工具栏导致Wi-Fi关闭，影响测试效果；等等。</li></ul><p>本节重点介绍的就是如何通过Monkey源码改造的方法来解决上述问题，以更好地提升Monkey的使用效果。<br>1.保持随机<br>2.尽可能让其他控件有相同机会<br>3.尽可能操作有意义的控件<br>4.尽可能覆盖到每个Activity </p><h1 id="Monkey代码重编译"><a href="#Monkey代码重编译" class="headerlink" title="Monkey代码重编译"></a>Monkey代码重编译</h1><p>monkey.jar的源码位于Android源码的<br>\development\cmds\monkey\src\com\android\commands\monkey 目录下，如图所示<br><img src="http://img.blog.csdn.net/20170123143738307?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVG9CZVRoZUVuZGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><hr><p><strong>Monkey重编译的方法有两种:</strong></p><ul><li>一种是在Linux环境下编译</li><li>另一种是在Windows环境下编译</li></ul><p>因为在Windows环境下编译更为常见，所以这里会重点介绍第二种方法。</p><h2 id="Linux环境下编译"><a href="#Linux环境下编译" class="headerlink" title="Linux环境下编译"></a>Linux环境下编译</h2><p>在Linux环境下，下载要测试Android系统版本对应的全部源代码，进入源码目录。</p><ul><li>执行.build/envsetup.sh，设置Android的编译环境</li><li>执行make monkey开始编译Monkey</li><li>编译成功后，可在/out/target/product/generic/system/framework/中获取Monkey.jar包。</li></ul><h2 id="Windows环境下编译"><a href="#Windows环境下编译" class="headerlink" title="Windows环境下编译"></a>Windows环境下编译</h2><p>Windows环境下的编译要稍微复杂一点。</p><ul><li>创建Monkey项目。同样也是需要下载要测试Android系统版本对应的全部源代码，在/development/cmds/monkey目录下找到Monkey的工程源码。在Eclipse中新建一个Java工程，把Monkey源码导入进去</li><li>设置Java Build Path。选中对应项目，在顶部菜单栏依次选题Project→Properties→Jave Build Path→Libraries，添加两个jar文件：android.jar和framework.jar。</li></ul><p>其中android.jar可以从Android Sdk中platforms\android-X\目录下获取；framework.jar可以通过以下两种方式获取。<br>（1）（推荐）从在Linux环境下Android源码根目录执行make update-api编译生成，如截图中的classes_dex2jar.jar文件就是通过Android源码编译生成的。<br>（2）直接从Android手机上/system/framework目录下获取已经编译好的framework.jar文件，把这个framework.jar解压，取出其dex，然后把它的dex通过dex2jar工具转换为jar包，导入工程。添加android和framework的jar包后，还需要将framework的jar包顺序调整到顶部，如图所示：<br><img src="http://img.blog.csdn.net/20170123144756497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVG9CZVRoZUVuZGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li><p>编译生成jar包。选择Monkey项目，单击右键→单击Export→选择输出的Jar包类型为“JAR file”类，单击“Next”按钮；选择对应的构建工程，填写jar包输出路径，单击“Next”按钮；进入打包选项页面，这里用默认选项即可，直接单击“Next”按钮；<br>选择工程中main函数所在的类，单击“Finish”按钮；编译完成后，在指定目录下就会生成对应的Monkey.jar包了。</p></li><li><p>转换Monkey.jar包。Eclipse编译出来的jar包是不能直接放到Android手机上运行的，在Android上无法像Java中那样方便地动态加载jar。原因是：Android的虚拟机（Dalvik VM）是不能识别Java打出的jar的byte code的，这里需要通过Android sdk中的dx工具来优化转换成Dalvik byte code才行。</p></li></ul><p>将打包好的jar复制到SDK安装目录android-sdk-windows\platform-tools下，打开命令行进入platform-tools目录，执行命令：<br>dx –dex –output=&lt;生成的目标文件&gt;  &lt;要转换的文件&gt;</p><h2 id="重编译的包运行方法"><a href="#重编译的包运行方法" class="headerlink" title="重编译的包运行方法"></a>重编译的包运行方法</h2><p>要运行重编译后的Monkey.jar有以下两个前提条件。<br>·手机拥有root权限。<br>·手机Android版本与Monkey.jar包的Android版本一致。<br>（由于不同版本的Android系统API不同，因此不同版本的Monkey包也是不能通用的。例如：Android 4.2版本的Monkey只能在Android 4.2的系统上运行。）</p><p>步骤1：创建启动shell脚本。<br>在本地新建一个用于启动Monkey的shell脚本，输入以下命令，并保存成Monkey。这个文件是用来启动和执行Monkey.jar的，如下面的代码所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Script to start &quot;monkeytest&quot;on the device, which has a very rudimentary</span><br><span class="line"># shell.</span><br><span class="line">#这里要填写编译后生成的jar文件名称</span><br><span class="line">export CLASSPATH=/data/ Monkey.jar</span><br><span class="line">#这里要填写jar文件中的入口函数所在类</span><br><span class="line">exec app_process /data com.android.debug.monkey.Monkey $*</span><br></pre></td></tr></table></figure><p>步骤2：上传脚本和jar包到手机。<br>将步骤1创建的Monkey脚本和Monkey.jar包上传到手机的/data/loal目录（可自己定义，与shell脚本中的目录一致即可），并将Monkey文件修改成可执行权限，如下面代码所示。<br>adb push Monkey.jar /data<br>adb push monkey /data<br>adb shell chmod777 /data/monkey<br>个别手机上执行chmod命令时会报Segmentation Fault错误，这时可以先adb shell进入，通过sw root命令切换到root下，再执行chrnod 777/data/monkey即可。</p><p>步骤3：运行monkey。<br>通过命令行窗口，输入 adb shell./data/local/monkey  命令启动Monkey.jar包即可运行Monkey。</p><hr><h1 id="Monkey源码改造"><a href="#Monkey源码改造" class="headerlink" title="Monkey源码改造"></a>Monkey源码改造</h1><p>代码目录如下：</p><p><img src="http://img.blog.csdn.net/20170123150405391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVG9CZVRoZUVuZGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="1-截图"><a href="#1-截图" class="headerlink" title="1. 截图"></a>1. 截图</h2><p>掌握重编译Monkey的方法后，接下来要开始进行Monkey源码改造了。第一个改造就是截图改造。Monkey使用过程中最大的难题就是如何获取异常出现的场景。虽然Monkey在执行过程中提供了日志来记录事件执行顺序，但是光靠日志来定位异常出现的场景并复现它是非常困难的。当Monkey执行过程中出现异常时，若可以对应进行截图并记录异常出现前执行的操作，就可以清晰地知道异常出现的场景，也便于定位和解决问题。</p><p>具体改造方法如下：<br>测试期望实现的是在每个事件执行过程中增加截图并在图片上画出事件轨迹。这里以屏幕触摸操作为例，首先找到触摸事件所在的文件MonkeyMotionEvent.java，找到负责执行该事件的injectMotionEvent方法。代码清单如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public int injectEvent(IWindowManager iwm, IActivityManager iam, int verbose) &#123;</span><br><span class="line">        MotionEvent me = getEvent();</span><br><span class="line">        if ((verbose &gt; 0 &amp;&amp; !mIntermediateNote) || verbose &gt; 1) &#123;</span><br><span class="line">            StringBuilder msg = new StringBuilder(&quot;:Sending &quot;);</span><br><span class="line">            msg.append(getTypeLabel()).append(&quot; (&quot;);</span><br><span class="line">            switch (me.getActionMasked()) &#123;</span><br><span class="line">                case MotionEvent.ACTION_DOWN:</span><br><span class="line">                    msg.append(&quot;ACTION_DOWN&quot;);</span><br><span class="line">                   </span><br><span class="line">                    //截图</span><br><span class="line">                    ImageUtils.takeScreenshot();</span><br><span class="line">                    //获取当前点击坐标，存到队列中</span><br><span class="line">                    ImageUtils.addPoint(me.getX(),me.getY());                         </span><br><span class="line">                    break;</span><br><span class="line">                case MotionEvent.ACTION_UP:</span><br><span class="line">                    msg.append(&quot;ACTION_UP&quot;);</span><br><span class="line">                    //获取当前点击坐标，存到队列中</span><br><span class="line">                    ImageUtils.addPoint(me.getX(),me.getY());</span><br><span class="line">                    //把队列中的点击坐标画到图片上</span><br><span class="line">                    Bitmap bc=ImageUtils.drawPoint(ImageUtils.scaleBitmap());</span><br><span class="line">            //bc=ImageUtils.lessenBitmap(bc,0.6f);//等比压缩</span><br><span class="line">            //bc=ImageUtils.zoomBitmap(bc,400);//等高压缩</span><br><span class="line">            ImageUtils.saveBitmap(bc);//保存图片</span><br><span class="line">                    //清空队列</span><br><span class="line">                    ImageUtils.removePointList();</span><br><span class="line">                    break;</span><br><span class="line">                  </span><br><span class="line">                case MotionEvent.ACTION_MOVE:</span><br><span class="line">                    msg.append(&quot;ACTION_MOVE&quot;);</span><br><span class="line">                    //获取当前点击坐标，存到队列中</span><br><span class="line">                    ImageUtils.addPoint(me.getX(),me.getY());</span><br><span class="line">                    break;</span><br><span class="line">                case MotionEvent.ACTION_CANCEL:</span><br><span class="line">                    msg.append(&quot;ACTION_CANCEL&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                case MotionEvent.ACTION_POINTER_DOWN:</span><br><span class="line">                    msg.append(&quot;ACTION_POINTER_DOWN &quot;).append(me.getPointerId(me.getActionIndex()));</span><br><span class="line">                    break;</span><br><span class="line">                case MotionEvent.ACTION_POINTER_UP:</span><br><span class="line">                    msg.append(&quot;ACTION_POINTER_UP &quot;).append(me.getPointerId(me.getActionIndex()));</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    msg.append(me.getAction());</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.append(&quot;):&quot;);</span><br><span class="line"></span><br><span class="line">            int pointerCount = me.getPointerCount();</span><br><span class="line">            for (int i = 0; i &lt; pointerCount; i++) &#123;</span><br><span class="line">                msg.append(&quot; &quot;).append(me.getPointerId(i));</span><br><span class="line">                msg.append(&quot;:(&quot;).append(me.getX(i)).append(&quot;,&quot;).append(me.getY(i)).append(&quot;)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(msg.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!InputManager.getInstance().injectInputEvent(me,</span><br><span class="line">                    InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT)) &#123;</span><br><span class="line">                return MonkeyEvent.INJECT_FAIL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            me.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        return MonkeyEvent.INJECT_SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参照上面的修改思路，将Monkey的其他方法也进行类似的修改。这样，Monkey每执行一个操作，系统就会自动对其进行截图描点了。</p><h2 id="2-Wi-Fi自动重连优化"><a href="#2-Wi-Fi自动重连优化" class="headerlink" title="2.Wi-Fi自动重连优化"></a>2.Wi-Fi自动重连优化</h2><p>我们知道大部分的应用程序是需要联网的，假如Monkey在执行过程中Wi-Fi断开了怎么办？由于Monkey执行的是随机事件流，过程中的操作无法控制，用户很容易误点到工具栏而导致Wi-Fi断开。对于需要联网的应用，当Wi-Fi断开后，很多页面都会无法打开，此时Monkey执行的效果会相当不理想。相信这也是绝大多数用户遇到的问题，当前小节介绍的就是如何通过Monkey改造来实现Wi-Fi断开重连的功能。<br>首先，新增一个用于Wi-Fi监控的事件MonkeyWifiEvent。在Monkey中新增一类事件有以下两个步骤。</p><ul><li>在MonkeyEvent新增一个eventType类型，如代码清单所示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publicabstractclassMonkeyEvent &#123;</span><br><span class="line">protectedinteventType;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_KEY = 0;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_TOUCH = 1;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_TRACKBALL = 2;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_ROTATION = 3;  // Screen rotation</span><br><span class="line">publicstaticfinalintEVENT_TYPE_ACTIVITY = 4;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_FLIP = 5;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_THROTTLE = 6;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_NOOP = 7;</span><br><span class="line">#新增一个Wi-Fi监控的事件类型</span><br><span class="line">publicstaticfinalintEVENT_TYPE_WifiCheck = 9;</span><br><span class="line">…</span><br></pre></td></tr></table></figure><ul><li>新增对应事件的MonkeyWifiEvent类，需继承自MonkeyEvent类，代码清单所示：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">publicclassMonkeyWifiEvent extendsMonkeyEvent&#123;</span><br><span class="line">//初始方法</span><br><span class="line">publicMonkeyWifiEvent() &#123;</span><br><span class="line">super(MonkeyEvent.EVENT_TYPE_WifiCheck);</span><br><span class="line">&#125;</span><br><span class="line">//调用CheckWifiConnection()方法检查Wi-Fi连接</span><br><span class="line">publicintinjectEvent(IWindowManager iwm, IActivityManager iam,intverbose)&#123;</span><br><span class="line">System.out.println(&quot;Check Wifi Conection.&quot;);</span><br><span class="line">wifiManager.CheckWifiConnection();</span><br><span class="line">returnMonkeyEvent.INJECT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，该事件是通过调用CheckWifiConnection（）方法来检查Wi-Fi连接并自动重连的。CheckWifiConnection（）方法的实现很简单，首先初始化一个WifiManager的对象，调用其getWifiEnabledState方法，检查当前Wi-Fi是否连接，当判断为Wi-Fi无连接时，调用setWifiEnabled方法打开Wi-Fi。等待Wi-Fi打开后，通过getConfiguredNetworks方法获取Wi-Fi列表，并遍历列表查找需要连接的Wi-Fi的SSID。查找到后，连接到对应的Wi-Fi上。具体实现如代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">publicstaticvoidCheckWifiConnection()&#123;</span><br><span class="line">IWifiManager im=IWifiManager.Stub.asInterface(ServiceManager</span><br><span class="line">.getService(&quot;wifi&quot;));</span><br><span class="line">try&#123;</span><br><span class="line">intstate=im.getWifiEnabledState();</span><br><span class="line">System.out.println(state);</span><br><span class="line">WifiInfo wi=im.getConnectionInfo();</span><br><span class="line">if(state!=3)&#123;</span><br><span class="line">//打开Wi-Fi</span><br><span class="line">System.out.println(&quot;Wifi not conect, connecting wifi.&quot;);</span><br><span class="line">im.setWifiEnabled(true);</span><br><span class="line">//等待Wi-Fi打开，然后连接freewifi</span><br><span class="line">for(inti=0;i&lt;90;i++)&#123;</span><br><span class="line">if(im.getWifiEnabledState()==3)&#123;</span><br><span class="line">//连接freewifi</span><br><span class="line">List t=im.getConfiguredNetworks();</span><br><span class="line">if(t!=null)&#123;</span><br><span class="line">for(int j=0;j</span><br><span class="line">if(t.get(j).SSID.indexOf(&quot;Tencent-FreeWiFi&quot;)!=-1)&#123;</span><br><span class="line">intnetworkid=t.get(j).networkId;</span><br><span class="line">im.enableNetwork(networkid, true);</span><br><span class="line">Thread.sleep(7000);</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">hread.sleep(2000);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch(RemoteException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch(InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;catch(SecurityException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说的需求是实现定时监控，所以需要在Monkey.java中的runMonkeyCycles（）下每隔1000个事件就插入一个Wi-Fi监控事件，实现如代码清单如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">privateintrunMonkeyCycles() &#123;</span><br><span class="line">inteventCounter = 0;</span><br><span class="line">intcycleCounter = 0;</span><br><span class="line">booleanshouldReportAnrTraces = false;</span><br><span class="line">booleanshouldReportDumpsysMemInfo = false;</span><br><span class="line">booleanshouldAbort = false;</span><br><span class="line">booleansystemCrashed = false;</span><br><span class="line">// TO DO : The count should apply to each of the script file.</span><br><span class="line">while(!systemCrashed &amp;&amp; cycleCounter &lt; mCount) &#123;</span><br><span class="line">...</span><br><span class="line">//添加Wi-Fi检查的事件—sharon</span><br><span class="line">if(cycleCounter%1000==0)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">addWifiEvent();</span><br><span class="line">&#125; catch(RemoteException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Events injected: &quot;+ eventCounter);</span><br><span class="line">returneventCounter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当Monkey每执行完1000个事件后，就会去检测一下Wi-Fi的连接状态，当发现Wi-Fi断开就会自动重连。重新编译一下Monkey，然后看一下效果，当Monkey检查到Wi-Fi断开会自动重连。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Monkey是Android测试中常用的一个稳定性测试工具，掌握Monkey工具本身的使用方法是非常简单的。但是真正能深入了解Monkey的代码实现逻辑，并且具备优化Monkey能力，还是需要一定难度。通过本blog，大家应该学习到Monkey的一些基本知识和基本使用方法，还可以通过对Monkey代码逻辑和扩展实例的学习，有所启发，掌握新的自动化测试的方案。</p><p>上面我说分析的只是截图功能和wifi重连功能，还有其他的功能，大家都可以去尝试开发，由于篇幅太长，我就不一一阐述啦，有问题随时留言，或加我微信一起探讨。。</p><p><img src="http://img.blog.csdn.net/20170123152604717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVG9CZVRoZUVuZGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;前面一遍blog
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="专项测试" scheme="http://yoursite.com/tags/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android稳定性测试-- Monkey源码分析</title>
    <link href="http://yoursite.com/2016/12/29/Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%B5%8B%E8%AF%95--%20Monkey%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2016/12/29/Android稳定性测试-- Monkey源码分析/</id>
    <published>2016-12-29T15:11:25.000Z</published>
    <updated>2018-05-01T12:23:02.262Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>前面一遍blog <a href="http://blog.csdn.net/tobetheender/article/details/53448949" target="_blank" rel="noopener">Monkey源码分析</a>讲到Monkey的代码结构和代码执行流程，相信通过介绍大家应该对monkey的运行原理和核心逻辑有了很深刻的了解。我们做的这一切都是为了更好的了解monkey的内部逻辑进行二次开发。<br>为什么要二次开发前面的文章也大概说了，它毕竟是一款为稳定性测试而准备的小工具，所以存在很多局限性：</p><ul><li>Monkey不提供<strong>截屏功能</strong>，因此测试很难找到问题复现的场景；</li><li>Monkey无法进行<strong>控件识别</strong>，对事件流控制能力很微弱；</li><li>执行过程中容易误点工具栏导致Wi-Fi关闭，影响测试效果；等等。</li></ul><p>本节重点介绍的就是如何通过Monkey源码改造的方法来解决上述问题，以更好地提升Monkey的使用效果。<br>1.保持随机<br>2.尽可能让其他控件有相同机会<br>3.尽可能操作有意义的控件<br>4.尽可能覆盖到每个Activity </p><h1 id="Monkey代码重编译"><a href="#Monkey代码重编译" class="headerlink" title="Monkey代码重编译"></a>Monkey代码重编译</h1><p>monkey.jar的源码位于Android源码的<br>\development\cmds\monkey\src\com\android\commands\monkey 目录下，如图所示<br><img src="http://img.blog.csdn.net/20170123143738307?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVG9CZVRoZUVuZGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><hr><p><strong>Monkey重编译的方法有两种:</strong></p><ul><li>一种是在Linux环境下编译</li><li>另一种是在Windows环境下编译</li></ul><p>因为在Windows环境下编译更为常见，所以这里会重点介绍第二种方法。</p><h2 id="Linux环境下编译"><a href="#Linux环境下编译" class="headerlink" title="Linux环境下编译"></a>Linux环境下编译</h2><p>在Linux环境下，下载要测试Android系统版本对应的全部源代码，进入源码目录。</p><ul><li>执行.build/envsetup.sh，设置Android的编译环境</li><li>执行make monkey开始编译Monkey</li><li>编译成功后，可在/out/target/product/generic/system/framework/中获取Monkey.jar包。</li></ul><h2 id="Windows环境下编译"><a href="#Windows环境下编译" class="headerlink" title="Windows环境下编译"></a>Windows环境下编译</h2><p>Windows环境下的编译要稍微复杂一点。</p><ul><li>创建Monkey项目。同样也是需要下载要测试Android系统版本对应的全部源代码，在/development/cmds/monkey目录下找到Monkey的工程源码。在Eclipse中新建一个Java工程，把Monkey源码导入进去</li><li>设置Java Build Path。选中对应项目，在顶部菜单栏依次选题Project→Properties→Jave Build Path→Libraries，添加两个jar文件：android.jar和framework.jar。</li></ul><p>其中android.jar可以从Android Sdk中platforms\android-X\目录下获取；framework.jar可以通过以下两种方式获取。<br>（1）（推荐）从在Linux环境下Android源码根目录执行make update-api编译生成，如截图中的classes_dex2jar.jar文件就是通过Android源码编译生成的。<br>（2）直接从Android手机上/system/framework目录下获取已经编译好的framework.jar文件，把这个framework.jar解压，取出其dex，然后把它的dex通过dex2jar工具转换为jar包，导入工程。添加android和framework的jar包后，还需要将framework的jar包顺序调整到顶部，如图所示：<br><img src="http://img.blog.csdn.net/20170123144756497?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVG9CZVRoZUVuZGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li><p>编译生成jar包。选择Monkey项目，单击右键→单击Export→选择输出的Jar包类型为“JAR file”类，单击“Next”按钮；选择对应的构建工程，填写jar包输出路径，单击“Next”按钮；进入打包选项页面，这里用默认选项即可，直接单击“Next”按钮；<br>选择工程中main函数所在的类，单击“Finish”按钮；编译完成后，在指定目录下就会生成对应的Monkey.jar包了。</p></li><li><p>转换Monkey.jar包。Eclipse编译出来的jar包是不能直接放到Android手机上运行的，在Android上无法像Java中那样方便地动态加载jar。原因是：Android的虚拟机（Dalvik VM）是不能识别Java打出的jar的byte code的，这里需要通过Android sdk中的dx工具来优化转换成Dalvik byte code才行。</p></li></ul><p>将打包好的jar复制到SDK安装目录android-sdk-windows\platform-tools下，打开命令行进入platform-tools目录，执行命令：<br>dx –dex –output=&lt;生成的目标文件&gt;  &lt;要转换的文件&gt;</p><h2 id="重编译的包运行方法"><a href="#重编译的包运行方法" class="headerlink" title="重编译的包运行方法"></a>重编译的包运行方法</h2><p>要运行重编译后的Monkey.jar有以下两个前提条件。<br>·手机拥有root权限。<br>·手机Android版本与Monkey.jar包的Android版本一致。<br>（由于不同版本的Android系统API不同，因此不同版本的Monkey包也是不能通用的。例如：Android 4.2版本的Monkey只能在Android 4.2的系统上运行。）</p><p>步骤1：创建启动shell脚本。<br>在本地新建一个用于启动Monkey的shell脚本，输入以下命令，并保存成Monkey。这个文件是用来启动和执行Monkey.jar的，如下面的代码所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Script to start &quot;monkeytest&quot;on the device, which has a very rudimentary</span><br><span class="line"># shell.</span><br><span class="line">#这里要填写编译后生成的jar文件名称</span><br><span class="line">export CLASSPATH=/data/ Monkey.jar</span><br><span class="line">#这里要填写jar文件中的入口函数所在类</span><br><span class="line">exec app_process /data com.android.debug.monkey.Monkey $*</span><br></pre></td></tr></table></figure><p>步骤2：上传脚本和jar包到手机。<br>将步骤1创建的Monkey脚本和Monkey.jar包上传到手机的/data/loal目录（可自己定义，与shell脚本中的目录一致即可），并将Monkey文件修改成可执行权限，如下面代码所示。<br>adb push Monkey.jar /data<br>adb push monkey /data<br>adb shell chmod777 /data/monkey<br>个别手机上执行chmod命令时会报Segmentation Fault错误，这时可以先adb shell进入，通过sw root命令切换到root下，再执行chrnod 777/data/monkey即可。</p><p>步骤3：运行monkey。<br>通过命令行窗口，输入 adb shell./data/local/monkey  命令启动Monkey.jar包即可运行Monkey。</p><hr><h1 id="Monkey源码改造"><a href="#Monkey源码改造" class="headerlink" title="Monkey源码改造"></a>Monkey源码改造</h1><p>代码目录如下：</p><p><img src="http://img.blog.csdn.net/20170123150405391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVG9CZVRoZUVuZGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h2 id="1-截图"><a href="#1-截图" class="headerlink" title="1. 截图"></a>1. 截图</h2><p>掌握重编译Monkey的方法后，接下来要开始进行Monkey源码改造了。第一个改造就是截图改造。Monkey使用过程中最大的难题就是如何获取异常出现的场景。虽然Monkey在执行过程中提供了日志来记录事件执行顺序，但是光靠日志来定位异常出现的场景并复现它是非常困难的。当Monkey执行过程中出现异常时，若可以对应进行截图并记录异常出现前执行的操作，就可以清晰地知道异常出现的场景，也便于定位和解决问题。</p><p>具体改造方法如下：<br>测试期望实现的是在每个事件执行过程中增加截图并在图片上画出事件轨迹。这里以屏幕触摸操作为例，首先找到触摸事件所在的文件MonkeyMotionEvent.java，找到负责执行该事件的injectMotionEvent方法。代码清单如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public int injectEvent(IWindowManager iwm, IActivityManager iam, int verbose) &#123;</span><br><span class="line">        MotionEvent me = getEvent();</span><br><span class="line">        if ((verbose &gt; 0 &amp;&amp; !mIntermediateNote) || verbose &gt; 1) &#123;</span><br><span class="line">            StringBuilder msg = new StringBuilder(&quot;:Sending &quot;);</span><br><span class="line">            msg.append(getTypeLabel()).append(&quot; (&quot;);</span><br><span class="line">            switch (me.getActionMasked()) &#123;</span><br><span class="line">                case MotionEvent.ACTION_DOWN:</span><br><span class="line">                    msg.append(&quot;ACTION_DOWN&quot;);</span><br><span class="line">                   </span><br><span class="line">                    //截图</span><br><span class="line">                    ImageUtils.takeScreenshot();</span><br><span class="line">                    //获取当前点击坐标，存到队列中</span><br><span class="line">                    ImageUtils.addPoint(me.getX(),me.getY());                         </span><br><span class="line">                    break;</span><br><span class="line">                case MotionEvent.ACTION_UP:</span><br><span class="line">                    msg.append(&quot;ACTION_UP&quot;);</span><br><span class="line">                    //获取当前点击坐标，存到队列中</span><br><span class="line">                    ImageUtils.addPoint(me.getX(),me.getY());</span><br><span class="line">                    //把队列中的点击坐标画到图片上</span><br><span class="line">                    Bitmap bc=ImageUtils.drawPoint(ImageUtils.scaleBitmap());</span><br><span class="line">            //bc=ImageUtils.lessenBitmap(bc,0.6f);//等比压缩</span><br><span class="line">            //bc=ImageUtils.zoomBitmap(bc,400);//等高压缩</span><br><span class="line">            ImageUtils.saveBitmap(bc);//保存图片</span><br><span class="line">                    //清空队列</span><br><span class="line">                    ImageUtils.removePointList();</span><br><span class="line">                    break;</span><br><span class="line">                  </span><br><span class="line">                case MotionEvent.ACTION_MOVE:</span><br><span class="line">                    msg.append(&quot;ACTION_MOVE&quot;);</span><br><span class="line">                    //获取当前点击坐标，存到队列中</span><br><span class="line">                    ImageUtils.addPoint(me.getX(),me.getY());</span><br><span class="line">                    break;</span><br><span class="line">                case MotionEvent.ACTION_CANCEL:</span><br><span class="line">                    msg.append(&quot;ACTION_CANCEL&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                case MotionEvent.ACTION_POINTER_DOWN:</span><br><span class="line">                    msg.append(&quot;ACTION_POINTER_DOWN &quot;).append(me.getPointerId(me.getActionIndex()));</span><br><span class="line">                    break;</span><br><span class="line">                case MotionEvent.ACTION_POINTER_UP:</span><br><span class="line">                    msg.append(&quot;ACTION_POINTER_UP &quot;).append(me.getPointerId(me.getActionIndex()));</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    msg.append(me.getAction());</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.append(&quot;):&quot;);</span><br><span class="line"></span><br><span class="line">            int pointerCount = me.getPointerCount();</span><br><span class="line">            for (int i = 0; i &lt; pointerCount; i++) &#123;</span><br><span class="line">                msg.append(&quot; &quot;).append(me.getPointerId(i));</span><br><span class="line">                msg.append(&quot;:(&quot;).append(me.getX(i)).append(&quot;,&quot;).append(me.getY(i)).append(&quot;)&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(msg.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (!InputManager.getInstance().injectInputEvent(me,</span><br><span class="line">                    InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_RESULT)) &#123;</span><br><span class="line">                return MonkeyEvent.INJECT_FAIL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            me.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">        return MonkeyEvent.INJECT_SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参照上面的修改思路，将Monkey的其他方法也进行类似的修改。这样，Monkey每执行一个操作，系统就会自动对其进行截图描点了。</p><h2 id="2-Wi-Fi自动重连优化"><a href="#2-Wi-Fi自动重连优化" class="headerlink" title="2.Wi-Fi自动重连优化"></a>2.Wi-Fi自动重连优化</h2><p>我们知道大部分的应用程序是需要联网的，假如Monkey在执行过程中Wi-Fi断开了怎么办？由于Monkey执行的是随机事件流，过程中的操作无法控制，用户很容易误点到工具栏而导致Wi-Fi断开。对于需要联网的应用，当Wi-Fi断开后，很多页面都会无法打开，此时Monkey执行的效果会相当不理想。相信这也是绝大多数用户遇到的问题，当前小节介绍的就是如何通过Monkey改造来实现Wi-Fi断开重连的功能。<br>首先，新增一个用于Wi-Fi监控的事件MonkeyWifiEvent。在Monkey中新增一类事件有以下两个步骤。</p><ul><li>在MonkeyEvent新增一个eventType类型，如代码清单所示</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publicabstractclassMonkeyEvent &#123;</span><br><span class="line">protectedinteventType;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_KEY = 0;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_TOUCH = 1;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_TRACKBALL = 2;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_ROTATION = 3;  // Screen rotation</span><br><span class="line">publicstaticfinalintEVENT_TYPE_ACTIVITY = 4;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_FLIP = 5;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_THROTTLE = 6;</span><br><span class="line">publicstaticfinalintEVENT_TYPE_NOOP = 7;</span><br><span class="line">#新增一个Wi-Fi监控的事件类型</span><br><span class="line">publicstaticfinalintEVENT_TYPE_WifiCheck = 9;</span><br><span class="line">…</span><br></pre></td></tr></table></figure><ul><li>新增对应事件的MonkeyWifiEvent类，需继承自MonkeyEvent类，代码清单所示：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">publicclassMonkeyWifiEvent extendsMonkeyEvent&#123;</span><br><span class="line">//初始方法</span><br><span class="line">publicMonkeyWifiEvent() &#123;</span><br><span class="line">super(MonkeyEvent.EVENT_TYPE_WifiCheck);</span><br><span class="line">&#125;</span><br><span class="line">//调用CheckWifiConnection()方法检查Wi-Fi连接</span><br><span class="line">publicintinjectEvent(IWindowManager iwm, IActivityManager iam,intverbose)&#123;</span><br><span class="line">System.out.println(&quot;Check Wifi Conection.&quot;);</span><br><span class="line">wifiManager.CheckWifiConnection();</span><br><span class="line">returnMonkeyEvent.INJECT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，该事件是通过调用CheckWifiConnection（）方法来检查Wi-Fi连接并自动重连的。CheckWifiConnection（）方法的实现很简单，首先初始化一个WifiManager的对象，调用其getWifiEnabledState方法，检查当前Wi-Fi是否连接，当判断为Wi-Fi无连接时，调用setWifiEnabled方法打开Wi-Fi。等待Wi-Fi打开后，通过getConfiguredNetworks方法获取Wi-Fi列表，并遍历列表查找需要连接的Wi-Fi的SSID。查找到后，连接到对应的Wi-Fi上。具体实现如代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">publicstaticvoidCheckWifiConnection()&#123;</span><br><span class="line">IWifiManager im=IWifiManager.Stub.asInterface(ServiceManager</span><br><span class="line">.getService(&quot;wifi&quot;));</span><br><span class="line">try&#123;</span><br><span class="line">intstate=im.getWifiEnabledState();</span><br><span class="line">System.out.println(state);</span><br><span class="line">WifiInfo wi=im.getConnectionInfo();</span><br><span class="line">if(state!=3)&#123;</span><br><span class="line">//打开Wi-Fi</span><br><span class="line">System.out.println(&quot;Wifi not conect, connecting wifi.&quot;);</span><br><span class="line">im.setWifiEnabled(true);</span><br><span class="line">//等待Wi-Fi打开，然后连接freewifi</span><br><span class="line">for(inti=0;i&lt;90;i++)&#123;</span><br><span class="line">if(im.getWifiEnabledState()==3)&#123;</span><br><span class="line">//连接freewifi</span><br><span class="line">List t=im.getConfiguredNetworks();</span><br><span class="line">if(t!=null)&#123;</span><br><span class="line">for(int j=0;j</span><br><span class="line">if(t.get(j).SSID.indexOf(&quot;Tencent-FreeWiFi&quot;)!=-1)&#123;</span><br><span class="line">intnetworkid=t.get(j).networkId;</span><br><span class="line">im.enableNetwork(networkid, true);</span><br><span class="line">Thread.sleep(7000);</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">break;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">hread.sleep(2000);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch(RemoteException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch(InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;catch(SecurityException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说的需求是实现定时监控，所以需要在Monkey.java中的runMonkeyCycles（）下每隔1000个事件就插入一个Wi-Fi监控事件，实现如代码清单如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">privateintrunMonkeyCycles() &#123;</span><br><span class="line">inteventCounter = 0;</span><br><span class="line">intcycleCounter = 0;</span><br><span class="line">booleanshouldReportAnrTraces = false;</span><br><span class="line">booleanshouldReportDumpsysMemInfo = false;</span><br><span class="line">booleanshouldAbort = false;</span><br><span class="line">booleansystemCrashed = false;</span><br><span class="line">// TO DO : The count should apply to each of the script file.</span><br><span class="line">while(!systemCrashed &amp;&amp; cycleCounter &lt; mCount) &#123;</span><br><span class="line">...</span><br><span class="line">//添加Wi-Fi检查的事件—sharon</span><br><span class="line">if(cycleCounter%1000==0)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">addWifiEvent();</span><br><span class="line">&#125; catch(RemoteException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;Events injected: &quot;+ eventCounter);</span><br><span class="line">returneventCounter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当Monkey每执行完1000个事件后，就会去检测一下Wi-Fi的连接状态，当发现Wi-Fi断开就会自动重连。重新编译一下Monkey，然后看一下效果，当Monkey检查到Wi-Fi断开会自动重连。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Monkey是Android测试中常用的一个稳定性测试工具，掌握Monkey工具本身的使用方法是非常简单的。但是真正能深入了解Monkey的代码实现逻辑，并且具备优化Monkey能力，还是需要一定难度。通过本blog，大家应该学习到Monkey的一些基本知识和基本使用方法，还可以通过对Monkey代码逻辑和扩展实例的学习，有所启发，掌握新的自动化测试的方案。</p><p>上面我说分析的只是截图功能和wifi重连功能，还有其他的功能，大家都可以去尝试开发，由于篇幅太长，我就不一一阐述啦，有问题随时留言，或加我微信一起探讨。。</p><p><img src="http://img.blog.csdn.net/20170123152604717?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvVG9CZVRoZUVuZGVy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;前面一遍blog
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="专项测试" scheme="http://yoursite.com/tags/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ITester接口测试框架 (三) - 框架实现细节</title>
    <link href="http://yoursite.com/2016/12/22/ITester%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%20(%E4%B8%89)%20-%20%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
    <id>http://yoursite.com/2016/12/22/ITester接口测试框架 (三) - 框架实现细节/</id>
    <published>2016-12-22T14:40:22.000Z</published>
    <updated>2018-05-01T12:20:13.662Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>结构图</p><p><img src="http://img.blog.csdn.net/20161124193935168" alt="这里写图片描述"></p><hr><h1 id="框架实现"><a href="#框架实现" class="headerlink" title="框架实现"></a>框架实现</h1><h2 id="1-数据准备-和-参数输入"><a href="#1-数据准备-和-参数输入" class="headerlink" title="1.数据准备 和 参数输入"></a>1.数据准备 和 参数输入</h2><p>数据准备有三种方式：</p><ul><li>一：通过访问数据库，获取我们需要的接口测试参数，比如测试登录接口，我们要提前获得 用户名和密码，然后才能连同我们的url发送给服务端。</li></ul><p>要想访问数据库，必须要先与数据库建立连接，我这里采用的是JDBC 和C3P0，可以参考我之前的blog<br><a href="http://blog.csdn.net/tobetheender/article/details/52772157" target="_blank" rel="noopener">Java通过JDBC 进行MySQL数据库操作</a><br><a href="http://blog.csdn.net/tobetheender/article/details/52841983" target="_blank" rel="noopener">Java数据库连接池 学习笔记</a></p><ul><li>二：直接将所需要的数据写入到xml或者excel中，然后写一个工具类直接去读取就行。</li></ul><p><strong>例如 ：要准备 测试接口输入参数为：email和password</strong></p><p>（1）编写paramsData.xml，将上述参数放在xml中进行管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;map&gt;   </span><br><span class="line">&lt;bean beanName=&quot;signIn&quot;&gt; </span><br><span class="line">&lt;locator name=&quot;email&quot; value=&quot;charlie.chen@dji.com&quot;&gt;&lt;/locator&gt;</span><br><span class="line">&lt;locator name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/locator&gt; </span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;/map&gt;</span><br></pre></td></tr></table></figure><p>（2）封装一个XmlUtil工具类负责读取xml ,使用第三方的jar包dom4j，XmlUtil中readXMLDocument方法返回值为Map&lt;String, String&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, String&gt; readXMLDocument(String xmlPath, String beanName) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述readXMLDocument方法中，参数xmlName为xml文件的名字； 参数beanName为xml文件中节点的名称。</p><ul><li>三：通过xml管理测试数据，也可以用Excel进行管理</li></ul><p>和xml管理数据类似：封装一个ExcelUtil工具类负责读取excel ,使用第三方的jar包poi，ExcelUtil中readExcel方法返回值为List&lt;ParamBean<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 读取Excel中数据</span><br><span class="line">public static List&lt;ParamBean&gt; readExcel(String excelPath) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-请求执行"><a href="#2-请求执行" class="headerlink" title="2.请求执行"></a>2.请求执行</h2><p>（1）封装一个CookieUtil工具类，通过CookieStore储存cookie<br>CookieUtil类中setCookieStore方法返回值为CookieStore</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 将服务端返回的SessionID存储在CookieStore中</span><br><span class="line"> * @author Charlie.chen</span><br><span class="line"> * @date 2016-10-31</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class CookieUtil &#123;</span><br><span class="line"></span><br><span class="line">    private static CookieStore cookieStore = null;</span><br><span class="line">    private static LogUtil log = new LogUtil(CookieUtil.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 通过CookieStore储存cookie</span><br><span class="line">     */</span><br><span class="line">    public static CookieStore setCookieStore(HttpResponse httpResponse) &#123;</span><br><span class="line">    </span><br><span class="line">        log.info(&quot;setCookieStore&quot;);</span><br><span class="line">        cookieStore = new BasicCookieStore();</span><br><span class="line">        // JSESSIONID</span><br><span class="line">        String setCookie = httpResponse.getFirstHeader(&quot;Set-Cookie&quot;).getValue();</span><br><span class="line">        String JSESSIONID = setCookie.substring(&quot;JSESSIONID=&quot;.length(),</span><br><span class="line">        setCookie.indexOf(&quot;;&quot;));</span><br><span class="line">        log.debug(&quot;JSESSIONID:&quot; + JSESSIONID);</span><br><span class="line">        </span><br><span class="line">        // 新建一个Cookie</span><br><span class="line">        BasicClientCookie cookie = new BasicClientCookie(&quot;JSESSIONID&quot;, JSESSIONID);</span><br><span class="line">        cookie.setVersion(0);</span><br><span class="line">        cookie.setDomain(&quot;127.0.0.1&quot;);</span><br><span class="line">        cookie.setPath(&quot;/CwlProClient&quot;);</span><br><span class="line">       </span><br><span class="line">        cookieStore.addCookie(cookie);</span><br><span class="line">        return cookieStore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述setCookieStore方法中，httpResponse参数为服务端响应值，类型为HttpResponse</p><p>（2）用httpClient简单封装一个httpClientUtil工具类有get.post,put,delete方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static CloseableHttpResponse doGet(String url, Map&lt;String, String&gt; paramsMap, CloseableHttpClient httpclient, CookieStore cookieStore) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static CloseableHttpResponse doPost(String url, Map&lt;String, String&gt; paramsMap, CloseableHttpClient httpclient,CookieStore cookieStore) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static CloseableHttpResponse doPut(String url, Map&lt;String, String&gt; paramsMap, CloseableHttpClient httpclient, CookieStore cookieStore) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static CloseableHttpResponse doDelete(String url, Map&lt;String, String&gt; paramsMap, CloseableHttpClient httpclient, CookieStore cookieStore) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 封装一个获取请求实体的方法</span><br><span class="line">* @param params</span><br><span class="line">* @param ucode</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static UrlEncodedFormEntity getFormEntity(Map&lt;String, String&gt; paramsMap, Charset... ucode) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-结果解析-和-验证"><a href="#3-结果解析-和-验证" class="headerlink" title="3.结果解析 和 验证"></a>3.结果解析 和 验证</h2><p>（1）将从服务端返回的HttpResponse结果解析为ResponseBean对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class ReponseUtil &#123;</span><br><span class="line"></span><br><span class="line">private static LogUtil log = new LogUtil(ReponseUtil.class);</span><br><span class="line">private static ResponseBean responseBean=null;</span><br><span class="line"></span><br><span class="line">public static ResponseBean setResponseBean(CloseableHttpResponse httpResponse) &#123;</span><br><span class="line"></span><br><span class="line">// 使用响应对象获取响应实体</span><br><span class="line">HttpEntity entity = httpResponse.getEntity();</span><br><span class="line">if (entity != null)</span><br><span class="line">try &#123;</span><br><span class="line">// 将响应实体转为字符串</span><br><span class="line">String responseString = EntityUtils.toString(entity, &quot;utf-8&quot;);</span><br><span class="line">String rs = responseString.replace(&quot;\r\n&quot;, &quot;&quot;);</span><br><span class="line"></span><br><span class="line">responseBean = new ResponseBean();</span><br><span class="line">responseBean.setStatus(httpResponse.getStatusLine().getReasonPhrase());</span><br><span class="line">responseBean.setStatusCode(Integer.toString(httpResponse.getStatusLine().getStatusCode()));</span><br><span class="line">responseBean.setBody(rs);</span><br><span class="line"></span><br><span class="line">log.info(&quot;\n&quot; + &quot;***************************返回开始**********************************&quot; + &quot;\n&quot;</span><br><span class="line">+ httpResponse.getStatusLine().getReasonPhrase() + &quot;\n&quot;</span><br><span class="line">+ Integer.toString(httpResponse.getStatusLine().getStatusCode()) + &quot;\n&quot; + &quot;Context&quot; + rs + &quot;\n&quot;</span><br><span class="line">+ &quot;***************************返回结束**********************************&quot;);</span><br><span class="line"></span><br><span class="line">HeaderIterator iterator = httpResponse.headerIterator();</span><br><span class="line">while (iterator.hasNext()) &#123;</span><br><span class="line">log.debug(&quot;\t&quot; + iterator.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">return responseBean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）结果验证<br>主要验证 HttpResponse的状态status，状态码statusCode和 响应实体body，通过第三方断言jar包AsertJ</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// add Assert</span><br><span class="line">Assert.assertEquals(&quot;OK&quot;, responseBean.getStatus());</span><br><span class="line">Assert.assertEquals(&quot;200&quot;, responseBean.getStatusCode());</span><br><span class="line">Assert.assertEquals(&quot;dsgfdfgdfsdfdgfdg&quot;, responseBean.getBody());</span><br></pre></td></tr></table></figure><h2 id="4-测试用例"><a href="#4-测试用例" class="headerlink" title="4.测试用例"></a>4.测试用例</h2><p>测试用例管理使用了testNG管理 ，使用了TestNG参数化测试，通过xml文件来执行case</p><p>（1）测试case脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">public class NewTest &#123;</span><br><span class="line"></span><br><span class="line">static CookieStore cookieStore=null;</span><br><span class="line"></span><br><span class="line">static CloseableHttpClient httpclient=null;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test() &#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">String url = PropertiesUtil.getValue(&quot;url&quot;,&quot;config.properties&quot;);</span><br><span class="line"></span><br><span class="line">String xmlPath=NewTest.class.getClassLoader().getResource(&quot;paramData.xml&quot;).getPath();</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; paramsMap = XmlUtil.readXMLDocument(xmlPath, &quot;signIn&quot;);</span><br><span class="line"></span><br><span class="line">httpclient = HttpClients.custom().setDefaultCookieStore(cookieStore).build();</span><br><span class="line">CloseableHttpResponse httpResponse = HttpClientUtil.doPost(url, paramsMap, httpclient, cookieStore);</span><br><span class="line"></span><br><span class="line">ResponseBean responseBean = ReponseUtil.setResponseBean(httpResponse);</span><br><span class="line"></span><br><span class="line">// add Assert</span><br><span class="line">Assert.assertEquals(&quot;OK&quot;, responseBean.getStatus());</span><br><span class="line">Assert.assertEquals(&quot;200&quot;, responseBean.getStatusCode());</span><br><span class="line">Assert.assertEquals(&quot;dsgfdfgdfsdfdgfdg&quot;, responseBean.getBody());</span><br><span class="line"></span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@BeforeClass</span><br><span class="line">public void beforeClass() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterClass</span><br><span class="line">public void afterClass() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@BeforeTest</span><br><span class="line">public void beforeTest() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterTest</span><br><span class="line">public void afterTest() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@BeforeSuite</span><br><span class="line">public void beforeSuite() &#123;</span><br><span class="line">/*</span><br><span class="line">* 登录进入系统获取JSESSIONID放入到CookieStore中</span><br><span class="line">* */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterSuite</span><br><span class="line">public void closeClient() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// 关闭流并释放资源</span><br><span class="line">httpclient.close();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）testng.xml文件的编写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;suite name=&quot;Suite&quot; parallel=&quot;false&quot; preserve-order=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;test name=&quot;Test&quot;&gt;</span><br><span class="line">    &lt;classes&gt;</span><br><span class="line">      &lt;class name=&quot;com.dji.itester.cases.NewTest&quot;&gt;</span><br><span class="line">      &lt;methods&gt;</span><br><span class="line">              &lt;include name=&quot;test&quot; /&gt;</span><br><span class="line">         &lt;/methods&gt;</span><br><span class="line">      &lt;/class&gt;</span><br><span class="line">    &lt;/classes&gt;</span><br><span class="line">  &lt;/test&gt; </span><br><span class="line">&lt;/suite&gt;</span><br></pre></td></tr></table></figure><p>右键-&gt;run as -&gt;TestNG Suite,这个场景的的测试用例就可以运行了</p><h2 id="5-失败用例重跑"><a href="#5-失败用例重跑" class="headerlink" title="5.失败用例重跑"></a>5.失败用例重跑</h2><p>关于失败用例重跑，在我前面的blog <a href="http://blog.csdn.net/tobetheender/article/details/52684633" target="_blank" rel="noopener">TestNG实现用例运行失败自动截图和重跑</a> 写的很清楚了，这里就不详说了，大概步骤如下：</p><p>（1）新建TestNGRetry类继承IRetryAnalyzer，实现用例失败自动重跑逻辑<br>（2）添加用例重跑监听器RetryListener，用例失败自动重跑功能<br>（3）在testng.xml文件中配置自己编写的监听器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;listeners&gt;</span><br><span class="line">    &lt;listener class-name=&quot;com.dji.itester.runfail.TestNGListener&quot; /&gt;</span><br><span class="line">    &lt;listener class-name=&quot;com.dji.itester.runfail.RetryListener&quot;/&gt;</span><br><span class="line">&lt;/listeners&gt;</span><br></pre></td></tr></table></figure></p><h2 id="6-源码管理-和-Jenkins配置"><a href="#6-源码管理-和-Jenkins配置" class="headerlink" title="6.源码管理 和 Jenkins配置"></a>6.源码管理 和 Jenkins配置</h2><p>（1）源码管理<br>将代码上传到github上进行托管，关于github的使用参考我前面的blog <a href="http://blog.csdn.net/tobetheender/article/details/52295021" target="_blank" rel="noopener">Git 学习笔记</a>）</p><p>（2）Jenkins配置<br>运行jenkins，首先创建一个job为ITester-DJI<br><img src="http://img.blog.csdn.net/20161125110536407" alt="这里写图片描述"></p><p>将代码上传到github上进行托管，然后在jenkins上配置clone 到你本地或者远程的jenkins来：<br><img src="http://img.blog.csdn.net/20161125110714144" alt="这里写图片描述"></p><p>构建触发器<br>Poll SCM： 定时检查源码变更（根据SCM软件的版本号），如果有更新就checkout最新code下来，然后执行构建动作。Build periodically：周期进行项目构建（它不care源码是否发生变化）<br>我的配置如下： 每天凌晨2：00进行一次构建</p><p><img src="http://img.blog.csdn.net/20161125110849560" alt="这里写图片描述"></p><p>构建<br><img src="http://img.blog.csdn.net/20161125110959936" alt="这里写图片描述"></p><p>构建后操作,发送邮件</p><h2 id="7-测试报告和邮件"><a href="#7-测试报告和邮件" class="headerlink" title="7.测试报告和邮件"></a>7.测试报告和邮件</h2><p>这里用到第三方的jar包ReportNG，对测试报告进行定制化。添加插件，关联testNg.xml,添加ReportNg的监听器，修改最后的TestNG的报告。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;!-- 添加插件，关联testNg.xml,添加ReportNg的监听器，修改最后的TestNG的报告 --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.18.1&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">&lt;forkMode&gt;once&lt;/forkMode&gt;  </span><br><span class="line">                   &lt;argLine&gt;-Dfile.encoding=UTF-8&lt;/argLine&gt; </span><br><span class="line"></span><br><span class="line">&lt;suiteXmlFiles&gt;</span><br><span class="line">&lt;!--&lt;suiteXmlFile&gt;testng.xml&lt;/suiteXmlFile&gt;  --&gt;</span><br><span class="line">    &lt;suiteXmlFile&gt;src/test/java/com/dji/itester/testSuites/$&#123;xmlFileName&#125;&lt;/suiteXmlFile&gt; </span><br><span class="line">&lt;/suiteXmlFiles&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;usedefaultlisteners&lt;/name&gt;</span><br><span class="line">&lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;listener&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.uncommons.reportng.HTMLReporter,</span><br><span class="line">org.uncommons.reportng.JUnitXMLReporter&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;workingDirectory&gt;target/&lt;/workingDirectory&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;source&gt;1.6&lt;/source&gt;</span><br><span class="line">&lt;target&gt;1.6&lt;/target&gt;</span><br><span class="line">&lt;encoding&gt;utf-8&lt;/encoding&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>测试报告：</p><p><img src="http://img.blog.csdn.net/20161125132520107" alt="这里写图片描述"></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;项目结构&quot;&gt;&lt;a href=&quot;#项目结构&quot; class=&quot;headerlink&quot; title=&quot;项目结构&quot;&gt;&lt;/a&gt;项目结构&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="接口测试" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ITester接口测试框架 (二) - 框架简介和流程图</title>
    <link href="http://yoursite.com/2016/12/22/ITester%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%20(%E4%BA%8C)%20-%20%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%E5%92%8C%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <id>http://yoursite.com/2016/12/22/ITester接口测试框架 (二) - 框架简介和流程图/</id>
    <published>2016-12-21T16:47:10.000Z</published>
    <updated>2018-05-01T12:18:15.953Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><h1 id="ITester框架简介"><a href="#ITester框架简介" class="headerlink" title="ITester框架简介"></a>ITester框架简介</h1><p>上一篇的blog主要讲解了接口测试的基础知识，这一章将详细介绍接口测试框架图和流程图。</p><p>ITester是处理API接口测试的轻量级自动化测试框架，java语言实现。主要是面向service接口，诸如：HTTP，SOAP，JSON-RPC的轻量级自动化测试框架。将数据准备、参数的输入、请求执行、结果解析、数据验证、数据清理各个环节都做了封装，以数据文本文件为接口，降低自动化测试过程中case书写的难度。底层主要使用的是HttpClient+TestNG</p><p><strong>工具特点：</strong></p><blockquote><ol><li>采取数据驱动方式，支持Excel 和Xml以及数据库的方式录入接口请求数据；</li><li>支持失败用例重跑；</li><li>支持用例多线程执行，缩短执行时间(用例间需线程安全)；</li><li>接入Jenkins持续集成平台，随时随地自动化构建，执行测试；</li><li>支持定制化测试报告，邮件通知测试结果。</li></ol></blockquote><hr><h1 id="ITester框架图"><a href="#ITester框架图" class="headerlink" title="ITester框架图"></a>ITester框架图</h1><p><img src="http://img.blog.csdn.net/20161125124053984" alt="这里写图片描述"></p><p>如图所示，我将框架分为五大部分：</p><ul><li>Client：也就是数据准备、参数的输入、请求执行、结果解析、数据验证、数据清理各个环节</li><li>TestCase：测试脚本用例模块</li><li>CI：也就是持续集成模块</li><li>Report：测试报告和邮件通知</li><li>调度：触发整个测试框架运行起来</li></ul><hr><h1 id="ITerster组件"><a href="#ITerster组件" class="headerlink" title="ITerster组件"></a>ITerster组件</h1><p><img src="http://img.blog.csdn.net/20161120173349065" alt="这里写图片描述"></p><p><strong>核心组件</strong></p><ol><li>通过Maven进行项目和依赖管理</li><li>通过HttpClient和服务端进行通信</li><li>通过TestNG进行测试脚本的管理</li><li>通过Log4j生成运行日志</li><li>通过Jackson实现各类型数据：javaBean，xml，json之间的相互转换</li><li>通过C3P0数据库连接池实现与数据库的连接通信</li><li>通过AssertJ提供丰富的断言</li><li>通过ReportNG输出丰富多彩的测试报告</li><li>最后将源码托管于Git通过Jenkins实现持续集成</li></ol><p><strong>调度执行</strong></p><ol><li>通过Maven进行项目的构建，测试</li><li>通过Shell脚本调度执行</li><li>通过Jenkins平台实现持续集成</li></ol><hr><h1 id="接口调用流程"><a href="#接口调用流程" class="headerlink" title="接口调用流程"></a>接口调用流程</h1><p><img src="http://img.blog.csdn.net/20161120183830546" alt="这里写图片描述"></p><hr><h1 id="用例执行流程"><a href="#用例执行流程" class="headerlink" title="用例执行流程"></a>用例执行流程</h1><p><img src="http://img.blog.csdn.net/20161120183539654" alt="这里写图片描述"></p><p>下一篇blog将主要介绍ITester接口框架的实现细节，后续相关的文档和源码会开源到github上！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;ITester框架简介&quot;&gt;&lt;a href=&quot;#ITester框架简介&quot; class=&quot;headerlink&quot; title=&quot;ITester框
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="接口测试" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>ITester接口测试框架 (一) ：接口基础知识</title>
    <link href="http://yoursite.com/2016/12/22/ITester%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%20(%E4%B8%80)%20%EF%BC%9A%E6%8E%A5%E5%8F%A3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2016/12/22/ITester接口测试框架 (一) ：接口基础知识/</id>
    <published>2016-12-21T16:12:30.000Z</published>
    <updated>2018-05-01T12:16:41.118Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><p>本系列教材将主要为大家讲解接口测试框架的设计，本框架属于轻量型的，目前的需求基本都能满足，后续还要不断的完善，最后开源出去。暂且命名为ITester（取名字是一件很蛋疼的事情，要与接口相关，又要不能和其他框架重名）</p><p>同样先规划下系列blog目录：<br>ITester接口测试框架(一)：接口基础知识<br>ITester接口测试框架(二)：框架简介和流程图<br>ITester接口测试框架(三)：框架实现细节</p><p>接下来开始第一部分，接口测试基础知识的讲解</p><h1 id="什么是接口测试"><a href="#什么是接口测试" class="headerlink" title="什么是接口测试"></a>什么是接口测试</h1><blockquote><p>接口是指系统模块与模块或系统与系统间进行交互,一般我们用的多的是HTTP协议的接口、WebService协议的接口,还有RPC (Remote Procedure Call Protocol)——远程过程调用协议的接口。</p></blockquote><p>接口测试是为了测试接口，尤其是那些与系统相关联的外部接口，测试的重点是要检查数据的交换，传递和控制管理过程，还包括处理的次数。<br>不管是哪种接口,其本质就是发送一个request,然后服务器响应 后返回一个response,然后我们对response进行分析,这即是接口测试。</p><h1 id="为什么要做接口测试"><a href="#为什么要做接口测试" class="headerlink" title="为什么要做接口测试"></a>为什么要做接口测试</h1><ul><li>首先，随着系统复杂程度的上升，传统的测试方法测试成本急剧增加，测试效率大幅下降（数据模型推算，底层的一个bug能够引发上层的 8 个左右bug，而且底层的bug很容易引起全网的宕机。相反接口测试能够提供系统复杂度上升情况下的低成本高效率的解决方案。</li><li>其次接口测试不同于传统开发的单元测试，接口测试是站在用户的角度对系统接口进行全面高效持续的检测。</li><li>最后接口测试是自动化并且持续集成的，这也是为什么接口测试能够低成本高收益的根源。</li></ul><p>接口测试的核心战略在于：以保证系统的正确和稳定为核心，以持续集成为手段，提高测试效率，提升用户体验，降低产品研发成本。</p><p>接口测试要为代码的编写保驾护航，增强开发人员和测试人员的自信，让隐含的 BUG提前暴露出来，要让开发人员在第一时间修复 BUG，要让功能测试人员和性能测试人员在测试的时候更加顺手，最大限度得减少底层 BUG 的出现数量，要让产品研发的流程更加敏捷，要缩短产品的研发周期，最后在产品上线以后，要让用户用得更加顺畅，要让用户感觉产品服务零缺陷。</p><p>另外在这个过程中，我们需要几类资源作为支撑，下面做简单描述。</p><ol><li>首先最重要的一点是要强调团队的重要性，特别是团队中需要有合理的人力资源配置，在这个团队中，需要全才，也需要专才，需要技术专家，也需要业务专家，既需要高效的执行者，也需要有效的管理者，任何人在这个团队中都可以发挥重要作用。</li><li>其次我们需要强大的测试技术以及测试框架去支撑我们的日常工作，包括基于 JAVA 以及基于 C++的测试框架，甚至以后会扩展到其他各个语种的框架，计算机软件的架构发展到今天，特别是分布式软件的发展，导致软件体系结构日益复杂化，各个系统之间的依赖逐渐加强，JAVA、C++以及多种技术的综合使用，使传统的单元测试已经无法满足于针对接口编程的架构方式，我们需要以一种更加干净的层面也就是从业务的层面对接口进行隔离测试，同时为了模拟真实场景，也需要在真实的环境中对系统内根据业务流程对各个接口进行串联测试，</li><li>最后以持续集成系统保证被测代码的稳定性。再次要充分重视文档的重要性，包括需求文档，开发技术方案，测试技术方案，接口定义 JAVADOC，测试用例文档等等，完善这些文档可以大大减少软件工程周期中各个团队配合障碍，也可以降低后期软件维护成本。因此贯彻和落实接口测试的战略可以最大程度地提高软件质量的稳定性。</li></ol><h1 id="接口的种类"><a href="#接口的种类" class="headerlink" title="接口的种类"></a>接口的种类</h1><ul><li>系统与系统之间的调用，比如支付宝会提供接口给DJI商城调用，或者说，支付宝会提供接口给天猫调用</li><li>上层服务对下层服务的调用，比如Service层会调用DAO层的接口，而应用层又会调用Service层提供的接口</li><li>服务之间的调用，比如注册用户时，会先调用用户查询的服务，查看该用户是否已经注册。</li></ul><p>而我们所要做的接口测试，先要了解是基于哪一种类型的接口测试，不同类型的接口测试方法可能是不一致的，总体来说，不管是哪种类型，我们只要把被测接口当做是服务方，而把我们的测试手段当做是客户方，我们的目的就是，通过我们的测试手段，去验证服务端满足了他声明提供的功能。</p><h1 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h1><p>参考我之前的csdn blog：<a href="http://blog.csdn.net/tobetheender/article/details/52277989" target="_blank" rel="noopener">HTTP 学习笔记</a></p><h2 id="GET方式提交"><a href="#GET方式提交" class="headerlink" title="GET方式提交"></a>GET方式提交</h2><p>   a）地址栏（URI）会跟上参数数据。以？开头，多个参数之间以&amp;分割。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /day09/testMethod.html?name=eric&amp;password=123456 HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://localhost:8080/day09/testMethod.html</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></p><p>b）GET提交参数数据有限制，不超过1KB。<br>c）GET方式不适合提交敏感密码。<br>d）注意： 浏览器直接访问的请求，默认提交方式是GET方式</p><h2 id="POST方式提交"><a href="#POST方式提交" class="headerlink" title="POST方式提交"></a>POST方式提交</h2><p>a）参数不会跟着URI后面。参数而是跟在请求的实体内容中。没有？开头，多个参数之间以&amp;分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST /day09/testMethod.html HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/20100101 Firefox/35.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://localhost:8080/day09/testMethod.html</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line">name=eric&amp;password=123456</span><br></pre></td></tr></table></figure><p>b）POST提交的参数数据没有限制。<br>c）POST方式提交敏感数据。</p><h1 id="接口测试的方法"><a href="#接口测试的方法" class="headerlink" title="接口测试的方法"></a>接口测试的方法</h1><p>至于接口测试具体的测试方法，http协议的接口测试，一般会用jmeter去测试，jmeter的好处是不用写测试代码，直接使用jmeter提供的http请求去测试，也可以使用postman，也可以使用HttpClient去测试，好处是可以方便集成和自动化。java接口的测试，则需要编写测试代码去测试，有点类似于单元测试。<br>　　但是以上的方法都只是通过发送Request，返回Respouse，简单的验证返回值是否正确，它的缺点很多：　　　　</p><ul><li>它不能将请求参数完全的覆盖，只是简单的覆盖几个参数</li><li>手动的一条一条伪造自测数据</li><li>对于复杂类型的请求参数，例如javaBean对象，无法发送</li><li>不能自动化的判断返回值是否正确</li><li>需要手工一条一条去执行接口，效率太低</li></ul><p>基于以上缺点，github上有很多同学做了各种不同的接口框架，比如百度的iTest，阿里taobao etao测试团队开发的TOAST，网易的Dagger，但是上述框架都是基于自己公司的业务基础设计开发的，只供参考，我自己设计了一套接口测试框架 ，暂且命名为ITester，详细介绍请看下一篇博文。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本系列教材将主要为大家讲解接口测试框架的设计，本框架属于轻量型的，目前的需求基本都能满足，后续还要不断的完善，最后开源出去。暂且命名为ITester（
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="接口测试" scheme="http://yoursite.com/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Android 性能数据采集（概要）</title>
    <link href="http://yoursite.com/2016/12/10/Android%20%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%EF%BC%88%E6%A6%82%E8%A6%81%EF%BC%89/"/>
    <id>http://yoursite.com/2016/12/10/Android 性能数据采集（概要）/</id>
    <published>2016-12-10T13:03:45.000Z</published>
    <updated>2018-05-01T12:27:55.294Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><blockquote><p>  adb shell dumpsys cpuinfo |grep packageName     &gt;/address/cpu.txt</p></blockquote><p>大家看第一个应用CPU占用率68%，这个过程是在用户（user）中花61%的时间，并在内核空间（kernel）花费7.1%的时间。</p><p>或者：</p><blockquote><p> adb shell top |grep packagename&gt;/address/cpu.txt </p></blockquote><hr><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="1-内存耗用："><a href="#1-内存耗用：" class="headerlink" title="1. 内存耗用："></a>1. 内存耗用：</h2><p>VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）<br>RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存）<br>PSS - Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）<br>USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）</p><p>1.空闲状态下的应用内存消耗情况<br>2.中等规格状态下的应用内存消耗情况<br>3.满规格状态下的应用内存消耗情况<br>4.应用内存峰值情况<br>5.应用内存泄露情况<br>6.应用是否常驻内存<br>7.压力测试后的内存使用情况</p><h2 id="2-内存问题："><a href="#2-内存问题：" class="headerlink" title="2. 内存问题："></a>2. 内存问题：</h2><ul><li>内存抖动</li></ul><p>大量的对象在短时间创建和释放，频繁触发GC，造成UI卡顿； 避免在循环体中new对象 String 和StringBuffer例子 避免在FrameCallback.doFrame()方法中new对象 重用对象 e.g 字符串拼接使用StringBuff</p><ul><li>内存泄露 OOM</li></ul><p>程序中一些对象不再使用，但是一直被该对象的引用所持有，导致GC无法回收。<br>Activity泄露：Activity Drawable<br>Fragment泄露</p><h2 id="3-内存采集方式："><a href="#3-内存采集方式：" class="headerlink" title="3. 内存采集方式："></a>3. 内存采集方式：</h2><p>1.使用 android 本身提供的 ActivityManager.MemoryInfo() 方法获得（此方法请百度或google）此类第三方工具有如网易的Emmagee、安测试、腾讯的GT等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void GetMemory() &#123;</span><br><span class="line"></span><br><span class="line">final ActivityManager activityManager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);    </span><br><span class="line"></span><br><span class="line">ActivityManager.MemoryInfo info = new ActivityManager.MemoryInfo();   </span><br><span class="line"></span><br><span class="line">activityManager.getMemoryInfo(info);    </span><br><span class="line"></span><br><span class="line">Log.i(tag,&quot;系统剩余内存:&quot;+(info.availMem &gt;&gt; 10)+&quot;k&quot;);   </span><br><span class="line"></span><br><span class="line">Log.i(tag,&quot;系统是否处于低内存运行：&quot;+info.lowMemory);</span><br><span class="line"></span><br><span class="line">Log.i(tag,&quot;当系统剩余内存低于&quot;+info.threshold+&quot;时就看成低内存运行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>availMem:表示系统剩余内存</p><p>lowMemory：它是boolean值，表示系统是否处于低内存运行</p><p>hreshold：它表示当系统剩余内存低于好多时就看成低内存运行</p><p>我用过以上三种最多，其实Top 也可以 还有很多方法都可以。</p><p>2.使用 android 提供的 adb shell dumpsys 命令来获取</p><blockquote><p> adb shell dumpsys meminfo |grep packagename &gt;/address/mem.txt </p></blockquote><p>3.使用 android 提供的 procrank<br>首先去google获取procrank、procmem、libpagemap.so 三个文件 ；</p><p>然后push文件，执行 </p><blockquote><p>adb push procrank /system/xbin adb push procmem /system/xbin adb push libpagemap.so /system/lib</p></blockquote><p>赋权</p><blockquote><p>adb shell chmod 6755 /system/xbin/procrank adb shell chmod 6755 /system/xbin/procmem adb shell chmod 6755 /system/lib/libpagemap.so</p></blockquote><p>在开启工具记录</p><blockquote><p> adb shell procrank |grep packagename &gt;/address/procrank.txt</p></blockquote><p>对于内存的限制 是 dalvik heap不能超过最大限制，跟Native heap没有关系。</p><hr><h1 id="流量"><a href="#流量" class="headerlink" title="流量"></a>流量</h1><p>流量测试包括以下测试项：</p><ul><li>应用首次启动流量提示</li><li>应用后台连续运行 2 小时的流量值</li><li>应用高负荷运行的流量峰值</li><li>应用中等负荷运行时的流量均值</li></ul><p>1.<br>adb shell cat /proc/“+Pid+”/net/dev”</p><p>这边的wlan0代表wifi 上传下载量标识! 上传下载量单位是字节可以/1024换算成KB<br>这里可以看到下载的字节数 、数据包 和 发送的字节数 、数据包<br>小技巧：wlan0这些值如何初始化0 很简单 你打开手机飞行模式再关掉就清0了</p><p>2.<br>通过直接读取android系统上的两个文件的内容：<br>Proc/uid_stat/{UID}/tcp_snd和tcp_rcv，其中UID是每个app安装时分配的唯一编号用于识别该app，tcp_snd中的数据表示法术的数据累计大小，单位是字节，tcp_rcv表示接收到的数据累计大小。</p><p>(1)首先获取app的PID：<br>adb shell ps |grep packageName<br>(2)然后获取app的UID<br>adb shell cat /proc/“+Pid+”/status<br>(3)获取到应用的起始的接收及发送的流量<br>adb shell cat /proc/uid_stat/+”UID”/tcp_rcv<br>adb shell cat /proc/uid_stat/+”UID”/tcp_snd<br>然后我们再操作应用，再次通过上述 2 条命令可以获取到应用的结束的接收及发送的流量，通过相减及得到应用的整体流量消耗</p><hr><h1 id="电量"><a href="#电量" class="headerlink" title="电量"></a>电量</h1><p>功耗测试主要从以下几个方面入手进行测试</p><p>测试手机安装目标APK前后待机功耗无明显差异<br>常见使用场景中能够正常进入待机，待机电流在正常范围内.<br>长时间连续使用应用无异常耗电现象</p><p>测试方法<br>第一种基于android提供的PowerManager.WakeLock来进行，<br>第二种比较复杂一点，功耗的计算=CPU消耗+Wake lock消耗+数据传输消耗+GPS消耗+Wi-Fi连接消耗，<br>第三种通过 adb shell dumpsys battery来获取</p><hr><h1 id="启动时长"><a href="#启动时长" class="headerlink" title="启动时长"></a>启动时长</h1><p>Android性能测试-启动时间：</p><p>首先我们来说说启动时间。关于应用的启动时间的测试，分为三类：</p><p>1） 首次启动 –应用首次启动所花费的时间<br>2） 非首次启动 –应用非首次启动所花费的时间<br>3） 应用界面切换–应用界面内切换所花费的时间</p><p>那么如何来做启动时间的测试呢，一般我们分为2类，一类为使用软件来测试，可能大部分人都比较通晓使用android 提供的 DisplayManager 来获取 activity 的启动时间。通过日志过滤关键字 Displayed 来过滤所有 activity 所打印的，记录日志通过。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h1&gt;&lt;blockq
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="专项测试" scheme="http://yoursite.com/tags/%E4%B8%93%E9%A1%B9%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>BeanUtils组件 学习笔记</title>
    <link href="http://yoursite.com/2016/12/07/BeanUtils%E7%BB%84%E4%BB%B6%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/12/07/BeanUtils组件 学习笔记/</id>
    <published>2016-12-07T14:52:29.000Z</published>
    <updated>2018-05-01T12:09:54.208Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><h2 id="一：BeanUtils组件简介"><a href="#一：BeanUtils组件简介" class="headerlink" title="一：BeanUtils组件简介"></a>一：BeanUtils组件简介</h2><h3 id="1-什么是BeanUtils"><a href="#1-什么是BeanUtils" class="headerlink" title="1.什么是BeanUtils"></a>1.什么是BeanUtils</h3><p>程序中对javabean的操作很频繁， 所以apache提供了一套开源的api，方便对javabean的操作，即BeanUtils组件。</p><h3 id="2-BeanUtils的作用"><a href="#2-BeanUtils的作用" class="headerlink" title="2.BeanUtils的作用"></a>2.BeanUtils的作用</h3><p>简化javabean的操作。<br>在一般的写bean组件的时候，都必须要写setter和getter方法，当然假如我们事先已经知道bean的相关属性和方法，写bean是比较简单的。</p><h3 id="3-BeanUtils依赖包"><a href="#3-BeanUtils依赖包" class="headerlink" title="3.BeanUtils依赖包"></a>3.BeanUtils依赖包</h3><p>用户可以从<a href="http://www.apache.org下载BeanUtils组件，然后再在项目中引入jar文件。" target="_blank" rel="noopener">www.apache.org下载BeanUtils组件，然后再在项目中引入jar文件。</a></p><p>(1)   BeanUtils相关包<br>commons-beanutils-1.8.3.jar<br>commons-beanutils-1.8.3-javadoc.jar<br>commons-beanutils-1.8.3-javadoc.jar<br>commons-beanutils-bean-collections-1.8.3.jar<br>commons-beanutils-core-1.8.3.jar</p><p>(2)   Logic4j相关包<br>commons-logging.jar<br>log4j.jar</p><p>注：如果缺少日志jar文件，报错：</p><blockquote><p>java.lang.NoClassDefFoundError: org/apache/commons/logging/LogFactory<br>    at org.apache.commons.beanutils.ConvertUtilsBean.<init>(ConvertUtilsBean.java:157)<br>    at org.apache.commons.beanutils.BeanUtilsBean.<init>(BeanUtilsBean.java:117)<br>    at org.apache.commons.beanutils.BeanUtilsBean$1.initialValue(BeanUtilsBean.java:68)<br>    at </init></init></p></blockquote><hr><h2 id="二：实例—基本用法"><a href="#二：实例—基本用法" class="headerlink" title="二：实例—基本用法"></a>二：实例—基本用法</h2><ul><li><p>用法1： 对象属性的拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanUtils.copyProperty(admin, &quot;userName&quot;, &quot;jack&quot;);</span><br><span class="line">BeanUtils.setProperty(admin, &quot;age&quot;, 18);</span><br></pre></td></tr></table></figure></li><li><p>用法2：对象的拷贝</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanUtils.copyProperties(newAdmin, admin);</span><br></pre></td></tr></table></figure><ul><li>用法3： map数据拷贝到javabean中<br>注意：map中的key要与javabean的属性名称一致</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanUtils.populate(adminMap, map);</span><br></pre></td></tr></table></figure><h3 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h3><ul><li>javabean类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">package com.beanutils.test;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 1. bean类设计</span><br><span class="line"> * @author Charlie.chen</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Admin &#123;</span><br><span class="line"></span><br><span class="line">private int id;</span><br><span class="line">private String userName;</span><br><span class="line">private String pwd;</span><br><span class="line">private int age;</span><br><span class="line">private Date birth;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Date getBirth() &#123;</span><br><span class="line">return birth;</span><br><span class="line">&#125;</span><br><span class="line">public void setBirth(Date birth) &#123;</span><br><span class="line">this.birth = birth;</span><br><span class="line">&#125;</span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">public String getPwd() &#123;</span><br><span class="line">return pwd;</span><br><span class="line">&#125;</span><br><span class="line">public void setPwd(String pwd) &#123;</span><br><span class="line">this.pwd = pwd;</span><br><span class="line">&#125;</span><br><span class="line">public int getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line">public void setId(int id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line">public String getUserName() &#123;</span><br><span class="line">return userName;</span><br><span class="line">&#125;</span><br><span class="line">public void setUserName(String userName) &#123;</span><br><span class="line">this.userName = userName;</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Admin [age=&quot; + age + &quot;, birth=&quot; + birth + &quot;, id=&quot; + id</span><br><span class="line">+ &quot;, pwd=&quot; + pwd + &quot;, userName=&quot; + userName + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过BeanUtils对javabean的基本操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test1() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">// a. 基本操作</span><br><span class="line">Admin admin = new Admin();</span><br><span class="line">//admin.setUserName(&quot;Charlie.chen&quot;);</span><br><span class="line">//admin.setPwd(&quot;999&quot;);</span><br><span class="line"></span><br><span class="line">// b. BeanUtils组件实现对象属性的拷贝</span><br><span class="line">BeanUtils.copyProperty(admin, &quot;userName&quot;, &quot;jack&quot;);</span><br><span class="line">BeanUtils.setProperty(admin, &quot;age&quot;, 18);</span><br><span class="line"></span><br><span class="line">// 总结1： 对于基本数据类型，会自动进行类型转换!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// c. 对象的拷贝</span><br><span class="line">Admin newAdmin = new Admin();</span><br><span class="line">BeanUtils.copyProperties(newAdmin, admin);</span><br><span class="line"></span><br><span class="line">// d. map数据，拷贝到对象中</span><br><span class="line">Admin adminMap = new Admin();</span><br><span class="line">Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();</span><br><span class="line">map.put(&quot;userName&quot;, &quot;Jerry&quot;);</span><br><span class="line">map.put(&quot;age&quot;, 29);</span><br><span class="line">// 注意：map中的key要与javabean的属性名称一致</span><br><span class="line">BeanUtils.populate(adminMap, map);</span><br><span class="line"></span><br><span class="line">// 测试</span><br><span class="line">System.out.println(adminMap.getUserName());</span><br><span class="line">System.out.println(adminMap.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三：实例—日期类型的拷贝"><a href="#三：实例—日期类型的拷贝" class="headerlink" title="三：实例—日期类型的拷贝"></a>三：实例—日期类型的拷贝</h2><p><strong>需要注册日期类型转换器，2种方式参见下面代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">//1.自定义日期类型转换器</span><br><span class="line">@Test</span><br><span class="line">public void test2() throws Exception &#123;</span><br><span class="line">// 模拟表单数据</span><br><span class="line">String name = &quot;jack&quot;;</span><br><span class="line">String age = &quot;20&quot;;</span><br><span class="line">String birth = &quot;   &quot;;</span><br><span class="line"></span><br><span class="line">// 对象</span><br><span class="line">Admin admin = new Admin();</span><br><span class="line">// 注册日期类型转换器：1， 自定义的方式</span><br><span class="line">ConvertUtils.register(new Converter() &#123;</span><br><span class="line">// 转换的内部实现方法，需要重写</span><br><span class="line">@Override</span><br><span class="line">public Object convert(Class type, Object value) &#123;</span><br><span class="line"></span><br><span class="line">// 判断</span><br><span class="line">if (type != Date.class) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">if (value == null || &quot;&quot;.equals(value.toString().trim())) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">// 字符串转换为日期</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">return sdf.parse(value.toString());</span><br><span class="line">&#125; catch (ParseException e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,Date.class);</span><br><span class="line"></span><br><span class="line">// 把表单提交的数据，封装到对象中</span><br><span class="line">BeanUtils.copyProperty(admin, &quot;userName&quot;, name);</span><br><span class="line">BeanUtils.copyProperty(admin, &quot;age&quot;, age);</span><br><span class="line">BeanUtils.copyProperty(admin, &quot;birth&quot;, birth);</span><br><span class="line"></span><br><span class="line">//------ 测试------</span><br><span class="line">System.out.println(admin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2. 使用提供的日期类型转换器工具类</span><br><span class="line">@Test</span><br><span class="line">public void test3() throws Exception &#123;</span><br><span class="line">// 模拟表单数据</span><br><span class="line">String name = &quot;jack&quot;;</span><br><span class="line">String age = &quot;20&quot;;</span><br><span class="line">String birth = null;</span><br><span class="line">// 对象</span><br><span class="line">Admin admin = new Admin();</span><br><span class="line"></span><br><span class="line">// 注册日期类型转换器：2， 使用组件提供的转换器工具类</span><br><span class="line">ConvertUtils.register(new DateLocaleConverter(), Date.class);</span><br><span class="line"></span><br><span class="line">// 把表单提交的数据，封装到对象中</span><br><span class="line">BeanUtils.copyProperty(admin, &quot;userName&quot;, name);</span><br><span class="line">BeanUtils.copyProperty(admin, &quot;age&quot;, age);</span><br><span class="line">BeanUtils.copyProperty(admin, &quot;birth&quot;, birth);</span><br><span class="line"></span><br><span class="line">//------ 测试------</span><br><span class="line">System.out.println(admin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一：BeanUtils组件简介&quot;&gt;&lt;a href=&quot;#一：BeanUtils组件简介&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java数据库连接池 学习笔记</title>
    <link href="http://yoursite.com/2016/12/06/Java%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/12/06/Java数据库连接池 学习笔记/</id>
    <published>2016-12-06T15:12:39.000Z</published>
    <updated>2018-05-01T12:10:30.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>对于一个简单的数据库应用，由于对于数据库的访问不是很频繁。这时可以简单地在需要访问数据库时，就新创建一个连接，用完后就关闭它，这样做也不会带来什么明显的性能上的开销。但是对于一个复杂的数据库应用，情况就完全不同了。频繁的建立、关闭连接，会极大的减低系统的性能，因此对于连接的使用成了系统性能的瓶颈。</p><p>正是由于以上原因，数据库连接池技术出现了！！</p><blockquote><p>数据库连接池负责分配,管理和释放数据库连接,它允许应用程序重复使用一个现有的数据库连接,而不是重新建立一个。</p></blockquote><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中, 这些数据库连接的数量是由最小数据库连接数来设定的.无论这些数据库连接是否被使用,连接池都将一直保证至少拥有这么多的连接数量.连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数,当应用程序向连接池请求的连接数超过最大连接数量时,这些请求将被加入到等待队列中。</p><hr><h1 id="数据库连接池优点："><a href="#数据库连接池优点：" class="headerlink" title="数据库连接池优点："></a>数据库连接池优点：</h1><p>1． 资源重用</p><p>由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程/线程的数量）。</p><p>2． 更快的系统响应速度</p><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。</p><p>3． 新的资源分配手段</p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，实现数据库连接池技术，几年钱也许还是个新鲜话题，对于目前的业务系统而言，如果设计中还没有考虑到连接池的应用，那么…….快在设计文档中加上这部分的内容吧。某一应用最大可用数据库连接数的限制，避免某一应用独占所有数据库资源。</p><p>4． 统一的连接管理，避免数据库连接泄漏</p><p>在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏。</p><hr><h1 id="数据库连接池技术实现"><a href="#数据库连接池技术实现" class="headerlink" title="数据库连接池技术实现"></a>数据库连接池技术实现</h1><p>目前数据库连接池技术实现常见有三种方式</p><ul><li>自定义数据库连接池</li><li>DBCP连接池</li><li>C3P0连接池</li></ul><h2 id="方式一：自定义数据库连接池"><a href="#方式一：自定义数据库连接池" class="headerlink" title="方式一：自定义数据库连接池"></a>方式一：自定义数据库连接池</h2><p><strong>程序实现思路</strong><br>1.指定“初始化连接数目” （App启动时，就执行创建）<br>2.指定“最大连接数”<br>3.指定“当前使用连接数” （不能超出最大连接数）</p><p><strong>代码实现思路</strong><br>1.MyPool.java 连接池<br>2.指定全局变量：初始化数目，最大连接数，当前连接数，连接池集合<br>3.构造方法：循环创建3个连接<br>4.写一个创建连接的方法<br>5.获取连接<br>     判断：池中有连接，直接连<br>           池中没有连接，判断是否达到最大的连接数：达到，抛出异常；没有达到，创建新连接<br>6.释放连接，连接池放回集合中</p><p><strong>代理</strong><br>    如果对某个接口中的某个指定的方法的功能进行扩展，而不想实现接口里所有方法，可以使用(动态)代理模式!<br>    Java中代理模式：静态/动态/Cglib代理(spring)<br>    使用动态代理，可以监测接口中方法的执行！</p><p>如何对Connection对象，生成一个代理对象：<br>|–Proxy<br>    static Object newProxyInstance(<br>ClassLoader loader,    当前使用的类加载器<br>Class<t>[] interfaces,   目标对象(Connection)实现的接口类型<br>InvocationHandler h    事件处理器：当执行上面接口中的方法的时候，就会自动触发事件处理器代码，把当前执行的方法(method)作为参数传入。<br>)  </t></p><p><strong>详细代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义连接池, 管理连接</span><br><span class="line"> * 代码实现：</span><br><span class="line">1.  MyPool.java  连接池类，   </span><br><span class="line">2.  指定全局参数：  初始化数目、最大连接数、当前连接、   连接池集合</span><br><span class="line">3.  构造函数：循环创建3个连接</span><br><span class="line">4.  写一个创建连接的方法</span><br><span class="line">5.  获取连接</span><br><span class="line">------&gt;  判断： 池中有连接， 直接拿</span><br><span class="line"> ------&gt;                池中没有连接，</span><br><span class="line">------&gt;                 判断，是否达到最大连接数； 达到，抛出异常；没有达到最大连接数，</span><br><span class="line">创建新的连接</span><br><span class="line">6. 释放连接</span><br><span class="line"> -------&gt;  连接放回集合中(..)</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyPool &#123;</span><br><span class="line"></span><br><span class="line">private int init_count = 3;// 初始化连接数目</span><br><span class="line">private int max_count = 6;// 最大连接数</span><br><span class="line">private int current_count = 0;  // 记录当前使用连接数</span><br><span class="line">// 连接池 （存放所有的初始化连接）</span><br><span class="line">private LinkedList&lt;Connection&gt; pool = new LinkedList&lt;Connection&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1.  构造函数中，初始化连接放入连接池</span><br><span class="line">public MyPool() &#123;</span><br><span class="line">// 初始化连接</span><br><span class="line">for (int i=0; i&lt;init_count; i++)&#123;</span><br><span class="line">// 记录当前连接数目</span><br><span class="line">current_count++;</span><br><span class="line">// 创建原始的连接对象</span><br><span class="line">Connection con = createConnection();</span><br><span class="line">// 把连接加入连接池</span><br><span class="line">pool.addLast(con);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2. 创建一个新的连接的方法</span><br><span class="line">private Connection createConnection()&#123;</span><br><span class="line">try &#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">// 原始的目标对象</span><br><span class="line">final Connection con = DriverManager.getConnection(&quot;jdbc:mysql:///jdbc_demo&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line"></span><br><span class="line">/**********对con对象代理**************/</span><br><span class="line"></span><br><span class="line">// 对con创建其代理对象</span><br><span class="line">Connection proxy = (Connection) Proxy.newProxyInstance(</span><br><span class="line"></span><br><span class="line">con.getClass().getClassLoader(),    // 类加载器</span><br><span class="line">//con.getClass().getInterfaces(),   // 当目标对象是一个具体的类的时候 </span><br><span class="line">new Class[]&#123;Connection.class&#125;,      // 目标对象实现的接口</span><br><span class="line"></span><br><span class="line">new InvocationHandler() &#123;// 当调用con对象方法的时候， 自动触发事务处理器</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">throws Throwable &#123;</span><br><span class="line">// 方法返回值</span><br><span class="line">Object result = null;</span><br><span class="line">// 当前执行的方法的方法名</span><br><span class="line">String methodName = method.getName();</span><br><span class="line"></span><br><span class="line">// 判断当执行了close方法的时候，把连接放入连接池</span><br><span class="line">if (&quot;close&quot;.equals(methodName)) &#123;</span><br><span class="line">System.out.println(&quot;begin:当前执行close方法开始！&quot;);</span><br><span class="line">// 连接放入连接池</span><br><span class="line">pool.addLast(con);</span><br><span class="line">System.out.println(&quot;end: 当前连接已经放入连接池了！&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 调用目标对象方法</span><br><span class="line">result = method.invoke(con, args);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">return proxy;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//3. 获取连接</span><br><span class="line">public Connection getConnection()&#123;</span><br><span class="line"></span><br><span class="line">// 3.1 判断连接池中是否有连接, 如果有连接，就直接从连接池取出</span><br><span class="line">if (pool.size() &gt; 0)&#123;</span><br><span class="line">return pool.removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3.2 连接池中没有连接： 判断，如果没有达到最大连接数，创建；</span><br><span class="line">if (current_count &lt; max_count) &#123;</span><br><span class="line">// 记录当前使用的连接数</span><br><span class="line">current_count++;</span><br><span class="line">// 创建连接</span><br><span class="line">return createConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 3.3 如果当前已经达到最大连接数，抛出异常</span><br><span class="line">throw new RuntimeException(&quot;当前连接已经达到最大连接数目 ！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//4. 释放连接</span><br><span class="line">public void realeaseConnection(Connection con) &#123;</span><br><span class="line">// 4.1 判断： 池的数目如果小于初始化连接，就放入池中</span><br><span class="line">if (pool.size() &lt; init_count)&#123;</span><br><span class="line">pool.addLast(con);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// 4.2 关闭 </span><br><span class="line">current_count--;</span><br><span class="line">con.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws SQLException &#123;</span><br><span class="line">MyPool pool = new MyPool();</span><br><span class="line">System.out.println(&quot;当前连接: &quot; + pool.current_count);  // 3</span><br><span class="line"></span><br><span class="line">// 使用连接</span><br><span class="line">pool.getConnection();</span><br><span class="line">pool.getConnection();</span><br><span class="line">Connection con4 = pool.getConnection();</span><br><span class="line">Connection con3 = pool.getConnection();</span><br><span class="line">Connection con2 = pool.getConnection();</span><br><span class="line">Connection con1 = pool.getConnection();</span><br><span class="line"></span><br><span class="line">// 释放连接, 连接放回连接池</span><br><span class="line">//pool.realeaseConnection(con1);</span><br><span class="line">/*</span><br><span class="line"> * 希望：当关闭连接的时候，要把连接放入连接池！【当调用Connection接口的close方法时候，希望触发pool.addLast(con);操作】</span><br><span class="line"> * 把连接放入连接池</span><br><span class="line"> * 解决1：实现Connection接口，重写close方法</span><br><span class="line"> * 解决2：动态代理</span><br><span class="line"> */</span><br><span class="line">con1.close();</span><br><span class="line"></span><br><span class="line">// 再获取</span><br><span class="line">pool.getConnection();</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;连接池：&quot; + pool.pool.size());      // 0</span><br><span class="line">System.out.println(&quot;当前连接: &quot; + pool.current_count);  // 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="方式二：DBCP连接池"><a href="#方式二：DBCP连接池" class="headerlink" title="方式二：DBCP连接池"></a>方式二：DBCP连接池</h2><p>DBCP 是 Apache 软件基金组织下的开源连接池实现，使用DBCP数据源，应用程序应在系统中增加如下两个 jar 文件：</p><ul><li>Commons-dbcp.jar：连接池的实现</li><li>Commons-pool.jar：连接池实现的依赖库</li></ul><p>Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。核心类：BasicDataSource</p><p> <strong>详细代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class App_DBCP &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">// 配置方式实现连接池,便于维护</span><br><span class="line">public void testProp() throws Exception &#123;</span><br><span class="line">// 加载prop配置文件</span><br><span class="line">Properties prop = new Properties();</span><br><span class="line">// 获取文件流</span><br><span class="line">InputStream inStream = App_DBCP.class.getResourceAsStream(&quot;db.properties&quot;);</span><br><span class="line">// 加载属性配置文件</span><br><span class="line">prop.load(inStream);</span><br><span class="line">// 根据prop配置，直接创建数据源对象</span><br><span class="line">DataSource dataSouce = BasicDataSourceFactory.createDataSource(prop);</span><br><span class="line"></span><br><span class="line">// 获取连接</span><br><span class="line">Connection con = dataSouce.getConnection();</span><br><span class="line">con.prepareStatement(&quot;delete from admin where id=4&quot;).executeUpdate();</span><br><span class="line">// 关闭</span><br><span class="line">con.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件db.properties</p><ul><li>url=jdbc:mysql:///jdbc_demo<br>driverClassName=com.mysql.jdbc.Driver<br>username=root<br>password=root<br>initialSize=3<br>maxActive=6<br>maxIdle=3000</li></ul><hr><h2 id="方式三：C3P0连接池"><a href="#方式三：C3P0连接池" class="headerlink" title="方式三：C3P0连接池"></a>方式三：C3P0连接池</h2><p>C3P0连接池，最常用的连接池技术！Spring框架，默认支持C3P0连接池技术！<br>C3P0连接池的核心jar包</p><ul><li>c3p0-0.9.1.2.jar</li></ul><p>核心类：CombopooledDataSource </p><p><strong>实现步骤：</strong></p><ol><li>下载，引入jar文件:  c3p0-0.9.1.2.jar</li><li>使用连接池，创建连接<br>a)    硬编码方式<br>b)    配置方式(xml)</li></ol><p><strong>具体代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">//XML配置方式，使用C3P0连接池管理连接</span><br><span class="line">public void testXML() throws Exception &#123;</span><br><span class="line">// 创建c3p0连接池核心工具类</span><br><span class="line">// 自动加载src下c3p0的配置文件【c3p0-config.xml】</span><br><span class="line">ComboPooledDataSource dataSource = new ComboPooledDataSource();// 使用默认的配置</span><br><span class="line"></span><br><span class="line">// 获取连接</span><br><span class="line">Connection con = dataSource.getConnection();</span><br><span class="line">// 执行更新</span><br><span class="line">con.prepareStatement(&quot;delete from admin where id=5&quot;).executeUpdate();</span><br><span class="line">// 关闭</span><br><span class="line">con.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件c3p0-config.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;c3p0-config&gt;</span><br><span class="line">&lt;default-config&gt;</span><br><span class="line">&lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/jdbc_demo</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;password&quot;&gt;root&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;initialPoolSize&quot;&gt;3&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;maxPoolSize&quot;&gt;6&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;maxIdleTime&quot;&gt;1000&lt;/property&gt;</span><br><span class="line">&lt;/default-config&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;named-config name=&quot;oracle_config&quot;&gt;</span><br><span class="line">&lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/jdbc_demo&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;driverClass&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;password&quot;&gt;root&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;initialPoolSize&quot;&gt;3&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;maxPoolSize&quot;&gt;6&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;maxIdleTime&quot;&gt;1000&lt;/property&gt;</span><br><span class="line">&lt;/named-config&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/c3p0-config&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;对于一个简单的数
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java通过JDBC 进行Dao层的封装</title>
    <link href="http://yoursite.com/2016/12/05/Java%E9%80%9A%E8%BF%87JDBC%20%E8%BF%9B%E8%A1%8CDao%E5%B1%82%E7%9A%84%E5%B0%81%E8%A3%85/"/>
    <id>http://yoursite.com/2016/12/05/Java通过JDBC 进行Dao层的封装/</id>
    <published>2016-12-05T14:22:45.000Z</published>
    <updated>2018-05-01T12:05:31.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面有一章节，我专门讲解了<a href="http://blog.csdn.net/tobetheender/article/details/52772157" target="_blank" rel="noopener">Java通过JDBC 进行MySQL数据库操作</a>，这主要讲解了MySQL数据库的连接和简单的操作，但是在真正的java项目中，我们要不断的和数据库打交道，为了提高数据库操作的执行效率和增加代码的复用性，将重新封装一个Dao层，也就是数据访问层 ，用来访问数据库实现数据的持久化。</p><h2 id="Dao层设计"><a href="#Dao层设计" class="headerlink" title="Dao层设计"></a>Dao层设计</h2><p>###Dao层操作通用的步骤：</p><ul><li>1.写SQL语句</li><li>2.获取连接</li><li>3.创建stmt</li><li>4.执行sql</li></ul><blockquote><p>a)更新<br>String sql = “delete from admin where id=?””;<br>String sql = “insert into admin (userName,pwd) values (?,?)”<br>public void update(String sql, Object[]  paramValues);</p></blockquote><blockquote><p>b)查询<br>String sql = “select <em> from admin”;<br>String sql = “select </em> from admin  where  id=?  And pwd =?”;<br>// 传入的什么类型的对象，就封装为什么类型<br>// 要求： 列的名称，要与指定类型的对象的属性名称一样<br>Public    List<t>    query  (String sql , Object[] paramValues ,  Class<t> clazz);<br>T  t;  // 对象赋值</t></t></p></blockquote><ul><li>5.关闭/异常</li></ul><h3 id="编写BaseDao，自己写的所有的Dao都继承此类"><a href="#编写BaseDao，自己写的所有的Dao都继承此类" class="headerlink" title="编写BaseDao，自己写的所有的Dao都继承此类"></a>编写BaseDao，自己写的所有的Dao都继承此类</h3><p>其中JDBCUtil类在上篇博文<a href="http://blog.csdn.net/tobetheender/article/details/52772157" target="_blank" rel="noopener">Java通过JDBC 进行MySQL数据库操作</a>中有详细介绍，这里就比说了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 通用的dao，自己写的所有的dao都继承此类;</span><br><span class="line"> * 此类定义了2个通用的方法：</span><br><span class="line"> * 1. 更新</span><br><span class="line"> *  2. 查询</span><br><span class="line"> * @author Charlie.chen</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class BaseDao &#123;</span><br><span class="line"></span><br><span class="line">// 初始化参数</span><br><span class="line">private Connection con;</span><br><span class="line">private PreparedStatement pstmt;</span><br><span class="line">private ResultSet rs;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 查询的通用方法</span><br><span class="line"> * @param sql</span><br><span class="line"> * @param paramsValue</span><br><span class="line"> */</span><br><span class="line">public &lt;T&gt; List&lt;T&gt; query(String sql, Object[] paramsValue,Class&lt;T&gt; clazz)&#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">// 返回的集合</span><br><span class="line">List&lt;T&gt; list = new ArrayList&lt;T&gt;();</span><br><span class="line">// 对象</span><br><span class="line">T t = null;</span><br><span class="line"></span><br><span class="line">// 1. 获取连接</span><br><span class="line">con = JdbcUtil.getConnection();</span><br><span class="line">// 2. 创建stmt对象</span><br><span class="line">pstmt = con.prepareStatement(sql);</span><br><span class="line">// 3. 获取占位符参数的个数， 并设置每个参数的值</span><br><span class="line">int count = pstmt.getParameterMetaData().getParameterCount();</span><br><span class="line">if (paramsValue != null &amp;&amp; paramsValue.length &gt; 0) &#123;</span><br><span class="line">for (int i=0; i&lt;paramsValue.length; i++) &#123;</span><br><span class="line">pstmt.setObject(i+1, paramsValue[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 4. 执行查询</span><br><span class="line">rs = pstmt.executeQuery();</span><br><span class="line">// 5. 获取结果集元数据</span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">// ---&gt; 获取列的个数</span><br><span class="line">int columnCount = rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line">// 6. 遍历rs</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">// 要封装的对象</span><br><span class="line">t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">// 7. 遍历每一行的每一列, 封装数据</span><br><span class="line">for (int i=0; i&lt;columnCount; i++) &#123;</span><br><span class="line">// 获取每一列的列名称</span><br><span class="line">String columnName = rsmd.getColumnName(i + 1);</span><br><span class="line">// 获取每一列的列名称, 对应的值</span><br><span class="line">Object value = rs.getObject(columnName);</span><br><span class="line">// 封装： 设置到t对象的属性中  【BeanUtils组件】</span><br><span class="line">BeanUtils.copyProperty(t, columnName, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把封装完毕的对象，添加到list集合中</span><br><span class="line">list.add(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return list;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">JdbcUtil.closeAll(con, pstmt, rs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 更新的通用方法</span><br><span class="line"> * @param sql   更新的sql语句(update/insert/delete)</span><br><span class="line"> * @param paramsValue  sql语句中占位符对应的值(如果没有占位符，传入null)</span><br><span class="line"> */</span><br><span class="line">public void update(String sql,Object[] paramsValue)&#123;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">// 获取连接</span><br><span class="line">con = JdbcUtil.getConnection();</span><br><span class="line">// 创建执行命令的stmt对象</span><br><span class="line">pstmt = con.prepareStatement(sql);</span><br><span class="line">// 参数元数据： 得到占位符参数的个数</span><br><span class="line">int count = pstmt.getParameterMetaData().getParameterCount();</span><br><span class="line"></span><br><span class="line">// 设置占位符参数的值</span><br><span class="line">if (paramsValue != null &amp;&amp; paramsValue.length &gt; 0) &#123;</span><br><span class="line">// 循环给参数赋值</span><br><span class="line">for(int i=0;i&lt;count;i++) &#123;</span><br><span class="line">pstmt.setObject(i+1, paramsValue[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 执行更新</span><br><span class="line">pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">JdbcUtil.closeAll(con, pstmt, null);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="编写实际操作的Dao类继承自BaseDao"><a href="#编写实际操作的Dao类继承自BaseDao" class="headerlink" title="编写实际操作的Dao类继承自BaseDao"></a>编写实际操作的Dao类继承自BaseDao</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class AdminDao extends BaseDao &#123;</span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">public void delete(int id) &#123;</span><br><span class="line">String sql = &quot;delete from admin where id=?&quot;;</span><br><span class="line">Object[] paramsValue = &#123;id&#125;;</span><br><span class="line">super.update(sql, paramsValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入</span><br><span class="line">public void insert(Admin admin) &#123;</span><br><span class="line">String sql = &quot;insert into admin (userName,pwd) values (?,?)&quot;;</span><br><span class="line">Object[] paramsValue = &#123;admin.getUserName(),admin.getPwd()&#125;;</span><br><span class="line">super.update(sql, paramsValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查询全部</span><br><span class="line">public List&lt;Admin&gt; getAll()&#123;</span><br><span class="line">String sql = &quot;select * from admin&quot;;</span><br><span class="line">List&lt;Admin&gt; list = super.query(sql, null, Admin.class);</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 根据条件查询(主键)</span><br><span class="line">public Admin findById(int id)&#123;</span><br><span class="line">String sql = &quot;select * from admin where id=?&quot;;</span><br><span class="line">List&lt;Admin&gt; list = super.query(sql, new Object[]&#123;id&#125;, Admin.class);</span><br><span class="line">return  (list!=null&amp;&amp;list.size()&gt;0) ? list.get(0) : null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaBean类"><a href="#JavaBean类" class="headerlink" title="JavaBean类"></a>JavaBean类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 1. bean类设计</span><br><span class="line"> * @author Charlie.chen</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class Admin &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String userName;</span><br><span class="line">    private String pwd;</span><br><span class="line">    private int age;</span><br><span class="line">    private Date birth;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Date getBirth() &#123;</span><br><span class="line">        return birth;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setBirth(Date birth) &#123;</span><br><span class="line">        this.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getPwd() &#123;</span><br><span class="line">        return pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPwd(String pwd) &#123;</span><br><span class="line">        this.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getUserName() &#123;</span><br><span class="line">        return userName;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Admin [age=&quot; + age + &quot;, birth=&quot; + birth + &quot;, id=&quot; + id</span><br><span class="line">                + &quot;, pwd=&quot; + pwd + &quot;, userName=&quot; + userName + &quot;]&quot;;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前面有一章节，我
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java通过JDBC 进行MySQL数据库操作</title>
    <link href="http://yoursite.com/2016/12/05/Java%E9%80%9A%E8%BF%87JDBC%20%E8%BF%9B%E8%A1%8CMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2016/12/05/Java通过JDBC 进行MySQL数据库操作/</id>
    <published>2016-12-05T05:12:10.000Z</published>
    <updated>2018-05-01T12:04:30.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><h2 id="一：前言"><a href="#一：前言" class="headerlink" title="一：前言"></a>一：前言</h2><p>在测试工作中难免会和数据库打交道，可能大家对数据库语句都比较熟，比如常见的增删改查等，但是当我们在做自动化测试时，比如接口测试，大部分请求参数，可能都是从数据库中取值，并且接口返回值最后都会记录在数据库中，这样前提就需要和数据库建立连接，才能进行读写操作。</p><hr><h2 id="二：JDBC是什么"><a href="#二：JDBC是什么" class="headerlink" title="二：JDBC是什么"></a>二：JDBC是什么</h2><p><strong>java提供了一个API也就是JDBC（Java Data Base Connectivity)，可以为多种关系数据库提供统一访问和操作，它由一组用Java语言编写的类和接口组成。</strong></p><ul><li>没有jdbc之前<br>java开发人员需要维护不同的数据库的驱动程序，如果数据库的底层实现改变，驱动程序可能会随之改变！！</li></ul><p><img src="http://img.blog.csdn.net/20161015193028849" alt="这里写图片描述"></p><ul><li>有了jdbc之后：<br>java开发人员只需维护java应用和一套规范，也就是jdbc接口。数据库厂商提供具体的java驱动程序，数据库厂商的底层实现改变，厂商随之更新驱动程序，而不影响java应用程序！！</li></ul><p><img src="http://img.blog.csdn.net/20161015193227040" alt="这里写图片描述"></p><hr><h2 id="三：实现步骤"><a href="#三：实现步骤" class="headerlink" title="三：实现步骤"></a>三：实现步骤</h2><ol><li><p>导入数据包<br>需要包括含有需要进行数据库编程的JDBC类的包。大多数情况下，使用 import java.sql.*  就可以了.</p></li><li><p>添加JDBC驱动程序包<br> 添加jar程序驱动包<a href="http://www.mysql.com/downloads/connector/j，初始化驱动程序，可以与数据库打开一个通信通道。" target="_blank" rel="noopener">http://www.mysql.com/downloads/connector/j，初始化驱动程序，可以与数据库打开一个通信通道。</a></p></li><li><p>打开数据库连接<br>需要使用DriverManager.getConnection() 方法创建一个Connection对象，它代表与数据库的物理连接。</p></li><li><p>执行数据库操作<br> 需要使用类型声明的对象建立并提交一个SQL语句到数据库。</p></li><li><p>从结果集中提取数据<br> 要求使用适当的关于ResultSet.getXXX()方法来检索结果集的数据。</p></li><li><p>清理环境<br>需要明确地关闭所有的数据库资源相对依靠JVM的垃圾收集。</p></li></ol><h3 id="JDBCUtil类"><a href="#JDBCUtil类" class="headerlink" title="JDBCUtil类"></a>JDBCUtil类</h3><ul><li><p><strong>主程序</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">package com.jdbc;</span><br><span class="line"></span><br><span class="line">//导入数据包</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.sql.Connection;</span><br><span class="line">import java.sql.DriverManager;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.sql.Statement;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author Charlie.chen</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class JDBCUtil&#123;</span><br><span class="line"></span><br><span class="line">// 驱动包名和数据库url</span><br><span class="line">private static String url = null;</span><br><span class="line">private static String driverClass = null;</span><br><span class="line">// 数据库用户名和密码</span><br><span class="line">private static String userName = null;</span><br><span class="line">private static String password = null;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 初始化驱动程序</span><br><span class="line"> * 静态代码块中（只加载一次）</span><br><span class="line"> */</span><br><span class="line">static&#123;</span><br><span class="line">try &#123;</span><br><span class="line">//读取db.properties文件</span><br><span class="line">Properties prop = new Properties();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用类路径的读取方式</span><br><span class="line"> *  / : 斜杠表示classpath的根目录</span><br><span class="line"> *     在java项目下，classpath的根目录从bin目录开始</span><br><span class="line"> *     在web项目下，classpath的根目录从WEB-INF/classes目录开始</span><br><span class="line"> */</span><br><span class="line">InputStream in = JDBCUtil.class.getResourceAsStream(&quot;/db.properties&quot;);</span><br><span class="line"></span><br><span class="line">//加载文件</span><br><span class="line">prop.load(in);</span><br><span class="line">//读取信息</span><br><span class="line">url = prop.getProperty(&quot;url&quot;);</span><br><span class="line">driverClass = prop.getProperty(&quot;driverClass&quot;);</span><br><span class="line">userName = prop.getProperty(&quot;user&quot;);</span><br><span class="line">password = prop.getProperty(&quot;password&quot;);</span><br><span class="line"></span><br><span class="line">//注册驱动程序</span><br><span class="line">Class.forName(driverClass);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">System.out.println(&quot;驱程程序注册出错&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 打开数据库驱动连接</span><br><span class="line"> */</span><br><span class="line">public static Connection getConnection()&#123;</span><br><span class="line">try &#123;</span><br><span class="line">Connection conn = DriverManager.getConnection(url, userName, password);</span><br><span class="line">return conn;</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 清理环境，关闭连接(顺序:后打开的先关闭)</span><br><span class="line"> */</span><br><span class="line">public static void close(Connection conn,Statement stmt,ResultSet rs)&#123;</span><br><span class="line">if(rs!=null)</span><br><span class="line">try &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; catch (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">throw new RuntimeException(e1);</span><br><span class="line">&#125;</span><br><span class="line">if(stmt!=null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">stmt.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(conn!=null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">   </span><br><span class="line">   Connection conn = null;</span><br><span class="line">   Statement stmt = null;</span><br><span class="line">   ResultSet rs = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   conn=JDBCUtil.getConnection();</span><br><span class="line">   try &#123;</span><br><span class="line">stmt=conn.createStatement();</span><br><span class="line"> //准备sql操作语句</span><br><span class="line">String sql= &quot;SELECT id, first, last, age FROM YourDBName&quot;;</span><br><span class="line">rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">//从结果集中提取数据</span><br><span class="line">while(rs.next())&#123;</span><br><span class="line">         int id  = rs.getInt(&quot;id&quot;);</span><br><span class="line">         int age = rs.getInt(&quot;age&quot;);</span><br><span class="line">         String first = rs.getString(&quot;first&quot;);</span><br><span class="line">         String last = rs.getString(&quot;last&quot;);</span><br><span class="line"></span><br><span class="line">         System.out.print(&quot;ID: &quot; + id);</span><br><span class="line">         System.out.print(&quot;, Age: &quot; + age);</span><br><span class="line">         System.out.print(&quot;, First: &quot; + first);</span><br><span class="line">         System.out.println(&quot;, Last: &quot; + last);</span><br><span class="line">&#125;</span><br><span class="line">  &#125; catch (SQLException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">  &#125;finally&#123;</span><br><span class="line">  JDBCUtil.close(conn, stmt, rs);</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>JDBC配置文件db.properties</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql://localhost/yourDBName</span><br><span class="line">user=root</span><br><span class="line">password=root</span><br><span class="line">driverClass=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><hr><p>##四：JDBC核心API<br> JDBC接口核心的API</p><ul><li>java.sql.* </li><li>javax.sql.*</li></ul><pre><code>|- Driver接口： 表示java驱动程序接口。所有的具体的数据库厂商要来实现此接口。    |- connect(url, properties):  连接数据库的方法。            url: 连接数据库的URL                 URL语法： jdbc协议:数据库子协议://主机:端口/数据库                user： 数据库的用户名                password： 数据库用户密码|- DriverManager类： 驱动管理器类，用于管理所有注册的驱动程序    |-registerDriver(driver)  : 注册驱动类对象    |-Connection getConnection(url,user,password);  获取连接对象|- Connection接口： 表示java程序和数据库的连接对象。        |- Statement createStatement() ： 创建Statement对象        |- PreparedStatement prepareStatement(String sql)  创建PreparedStatement对象        |- CallableStatement prepareCall(String sql) 创建CallableStatement对象|- Statement接口： 用于执行静态的sql语句        |- int executeUpdate(String sql)  ： 执行静态的更新sql语句（DDL，DML）        |- ResultSet executeQuery(String sql)  ：执行的静态的查询sql语句（DQL）    |-PreparedStatement接口：用于执行预编译sql语句            |- int executeUpdate() ： 执行预编译的更新sql语句（DDL，DML）            |-ResultSet executeQuery()  ： 执行预编译的查询sql语句（DQL）    |-CallableStatement接口：用于执行存储过程的sql语句（call xxx）                |-ResultSet executeQuery()  ： 调用存储过程的方法|- ResultSet接口：用于封装查询出来的数据        |- boolean next() ： 将光标移动到下一行        |-getXX() : 获取列的值</code></pre><hr><h2 id="五：常见的SQL执行语句"><a href="#五：常见的SQL执行语句" class="headerlink" title="五：常见的SQL执行语句"></a>五：常见的SQL执行语句</h2><pre><code>String sql = &quot;CREATE TABLE student(id INT PRIMARY KEY AUTO_INCREMENT,NAME VARCHAR(20),gender VARCHAR(2))&quot;;//发送sql语句，执行sql语句,得到返回结果int count = stmt.executeUpdate(sql);String sql = &quot;SELECT * FROM student&quot;;//执行sqlResultSet rs = stmt.executeQuery(sql);String sql = &quot;INSERT INTO student(NAME,gender) VALUES(&apos;李四&apos;,&apos;女&apos;)&quot;;int count = stmt.executeUpdate(sql);String sql = &quot;UPDATE student SET NAME=&apos;&quot;+name+&quot;&apos; WHERE id=&quot;+id+&quot;&quot;;String sql = &quot;DELETE FROM student WHERE id=&quot;+id+&quot;&quot;;</code></pre><hr><h2 id="六：补充"><a href="#六：补充" class="headerlink" title="六：补充"></a>六：补充</h2><h3 id="数据库url制定"><a href="#数据库url制定" class="headerlink" title="数据库url制定"></a>数据库url制定</h3><p>当加载的驱动程序，可以建立程序中使用DriverManager.getConnection()方法的连接。为方便参考，让列出了三个重载DriverManager.getConnection()方法：</p><p>getConnection(String url)</p><p>getConnection(String url, Properties prop)</p><p>getConnection(String url, String user, String password)</p><p>在这里，每个表单需要一个数据库URL。数据库的URL是指向数据库地址。</p><p>制定一个数据库URL是大多数用在建立连接相关。<br>如图列出了下来流行的JDBC驱动程序名和数据库的URL。<br><img src="http://img.blog.csdn.net/20161012230516424" alt="这里写图片描述"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p> <a href="http://www.yiibai.com/jdbc/jdbc-sample-code.html#" target="_blank" rel="noopener">http://www.yiibai.com/jdbc/jdbc-sample-code.html#</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一：前言&quot;&gt;&lt;a href=&quot;#一：前言&quot; class=&quot;headerlink&quot; title=&quot;一：前言&quot;&gt;&lt;/a&gt;一：前言&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>TestNG实现用例运行失败自动截图和重跑</title>
    <link href="http://yoursite.com/2016/12/03/TestNG%E5%AE%9E%E7%8E%B0%E7%94%A8%E4%BE%8B%E8%BF%90%E8%A1%8C%E5%A4%B1%E8%B4%A5%E8%87%AA%E5%8A%A8%E6%88%AA%E5%9B%BE%E5%92%8C%E9%87%8D%E8%B7%91/"/>
    <id>http://yoursite.com/2016/12/03/TestNG实现用例运行失败自动截图和重跑/</id>
    <published>2016-12-03T10:44:10.000Z</published>
    <updated>2018-05-01T11:55:49.718Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面我的自动化测试框架系列文章中，有一个知识点没有讲到，现在补上。<br>在运行自动测试脚本时，经常会需要增加失败时自动截图的功能，以及失败重跑功能，下面介绍一下通过监听器的方式来实现自动截图和重跑功能。</p><h1 id="失败自动截图功能"><a href="#失败自动截图功能" class="headerlink" title="失败自动截图功能"></a>失败自动截图功能</h1><h3 id="1-定义一个截图工具类：ScreenShot"><a href="#1-定义一个截图工具类：ScreenShot" class="headerlink" title="1. 定义一个截图工具类：ScreenShot"></a>1. 定义一个截图工具类：ScreenShot</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package com.dji.utils;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.text.SimpleDateFormat;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.io.FileUtils;</span><br><span class="line">import org.openqa.selenium.OutputType;</span><br><span class="line"></span><br><span class="line">import io.appium.java_client.AppiumDriver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 截图并保存至本地</span><br><span class="line"> * </span><br><span class="line"> * @author Charlie.chen</span><br><span class="line"> */</span><br><span class="line">public class ScreenShot &#123;</span><br><span class="line"></span><br><span class="line">private AppiumDriver&lt;?&gt; driver;</span><br><span class="line">// 测试失败截屏保存的路径</span><br><span class="line">private String path;</span><br><span class="line">public LogUtil log=new LogUtil(this.getClass());</span><br><span class="line"></span><br><span class="line">public ScreenShot(AppiumDriver&lt;?&gt; driver)&#123;</span><br><span class="line">this.driver=driver;</span><br><span class="line">path=System.getProperty(&quot;user.dir&quot;)+ &quot;//snapshot//&quot;+ this.getClass().getSimpleName()+&quot;_&quot;+getCurrentTime() + &quot;.png&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void getScreenShot() &#123;</span><br><span class="line"></span><br><span class="line">File screen = driver.getScreenshotAs(OutputType.FILE);</span><br><span class="line">File screenFile = new File(path);</span><br><span class="line">try &#123;</span><br><span class="line">FileUtils.copyFile(screen, screenFile);</span><br><span class="line">log.info(&quot;截图保存的路径:&quot; + path);</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">log.error(&quot;截图失败&quot;);</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取当前时间</span><br><span class="line"> */</span><br><span class="line">public String getCurrentTime()&#123;</span><br><span class="line">Date date=new Date();</span><br><span class="line">SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy-MM-dd HH-mm-ss&quot;);</span><br><span class="line">String currentTime=sdf.format(date);</span><br><span class="line">return currentTime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getPath() &#123;</span><br><span class="line">return path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setPath(String path) &#123;</span><br><span class="line">this.path = path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-新建一个Java类继承TestListenerAdapter"><a href="#2-新建一个Java类继承TestListenerAdapter" class="headerlink" title="2. 新建一个Java类继承TestListenerAdapter"></a>2. 新建一个Java类继承TestListenerAdapter</h3><p>在TestNG中TestListenerAdapter为监听器类，共有如下主要方法：</p><ul><li>onTestFailure</li><li>onTestSuccess</li><li>onTestSuccess</li><li>onTestStart</li><li>onFinish</li></ul><p>要想实现用例运行失败自动截图，只需新建一个类TestNGListener继承TestListenerAdapter，然后重写onTestFailure、onTestSkipped等方法，在这些方法中加入截图操作即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.dji.utils;</span><br><span class="line"></span><br><span class="line">import org.testng.ITestContext;</span><br><span class="line">import org.testng.ITestResult;</span><br><span class="line">import org.testng.TestListenerAdapter;</span><br><span class="line"></span><br><span class="line">import io.appium.java_client.AppiumDriver;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * testNG执行case 失败后 ，testNG Listener会捕获执行失败</span><br><span class="line"> * 如果要实现失败自动截图，需要重写Listener的onTestFailure方法</span><br><span class="line"> * </span><br><span class="line"> * @author Charlie.chen</span><br><span class="line"> */</span><br><span class="line">public class TestNGListener extends TestListenerAdapter &#123;</span><br><span class="line"></span><br><span class="line">private static AppiumDriver&lt;?&gt; driver;</span><br><span class="line"></span><br><span class="line">LogUtil log = new LogUtil(this.getClass());</span><br><span class="line"></span><br><span class="line">public static void setDriver(AppiumDriver&lt;?&gt; driver) &#123;</span><br><span class="line">TestNGListener.driver = driver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onTestSuccess(ITestResult tr) &#123;</span><br><span class="line">log.info(&quot;Test Success&quot;);</span><br><span class="line">super.onTestSuccess(tr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onTestFailure(ITestResult tr) &#123;</span><br><span class="line">log.error(&quot;Test Failure&quot;);</span><br><span class="line">super.onTestFailure(tr);</span><br><span class="line"></span><br><span class="line">ScreenShot screenShot = new ScreenShot(driver);</span><br><span class="line">screenShot.getScreenShot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onTestSkipped(ITestResult tr) &#123;</span><br><span class="line">log.error(&quot;Test Skipped&quot;);</span><br><span class="line">super.onTestSkipped(tr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onStart(ITestContext testContext) &#123;</span><br><span class="line">log.info(&quot;Test Start&quot;);</span><br><span class="line">super.onStart(testContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onFinish(ITestContext testContext) &#123;</span><br><span class="line">log.info(&quot;Test Finish&quot;);</span><br><span class="line">super.onFinish(testContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-在testng-xml文件中配置自己编写的监听器类"><a href="#3-在testng-xml文件中配置自己编写的监听器类" class="headerlink" title="3. 在testng.xml文件中配置自己编写的监听器类"></a>3. 在testng.xml文件中配置自己编写的监听器类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listeners&gt;</span><br><span class="line">&lt;listener class-name=&quot;com.dji.utils.TestNGListener&quot; /&gt;</span><br><span class="line">&lt;/listeners&gt;</span><br></pre></td></tr></table></figure><hr><p>完成以上三步即可！！！</p><p><img src="http://img.blog.csdn.net/20160927205652964" alt="这里写图片描述"></p><hr><h1 id="失败自动重跑功能"><a href="#失败自动重跑功能" class="headerlink" title="失败自动重跑功能"></a>失败自动重跑功能</h1><h3 id="1-新建TestNGRetry类，实现用例失败自动重跑逻辑"><a href="#1-新建TestNGRetry类，实现用例失败自动重跑逻辑" class="headerlink" title="1. 新建TestNGRetry类，实现用例失败自动重跑逻辑"></a>1. 新建TestNGRetry类，实现用例失败自动重跑逻辑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.dji.utils;</span><br><span class="line"></span><br><span class="line">import org.testng.IRetryAnalyzer;</span><br><span class="line">import org.testng.ITestResult;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 用例失败自动重跑逻辑</span><br><span class="line"> * @author Charlie.chen</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class TestNGRetry implements IRetryAnalyzer &#123;</span><br><span class="line">public LogUtil log = new LogUtil(this.getClass());</span><br><span class="line">private int retryCount = 0;</span><br><span class="line">private int maxRetryCount=2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public boolean retry(ITestResult result) &#123;</span><br><span class="line">if (retryCount &lt;= maxRetryCount) &#123;</span><br><span class="line">String message = &quot;running retry for  &apos;&quot; + result.getName() + &quot;&apos; on class &quot; + </span><br><span class="line">                                       this.getClass().getName() + &quot; Retrying &quot; + retryCount + &quot; times&quot;;</span><br><span class="line">log.info(message);</span><br><span class="line">retryCount++;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-添加用例重跑监听器RetryListener，用例失败自动重跑功能"><a href="#2-添加用例重跑监听器RetryListener，用例失败自动重跑功能" class="headerlink" title="2. 添加用例重跑监听器RetryListener，用例失败自动重跑功能"></a>2. 添加用例重跑监听器RetryListener，用例失败自动重跑功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.dji.utils;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import org.testng.IAnnotationTransformer;</span><br><span class="line">import org.testng.IRetryAnalyzer;</span><br><span class="line">import org.testng.annotations.ITestAnnotation;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 添加用例重跑监听器，用例失败自动重跑功能</span><br><span class="line"> * </span><br><span class="line"> * @author Charlie.chen</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class RetryListener implements IAnnotationTransformer &#123;</span><br><span class="line">    public void transform(ITestAnnotation annotation, Class testClass, Constructor testConstructor, Method testMethod) &#123;</span><br><span class="line">        IRetryAnalyzer retry = annotation.getRetryAnalyzer();</span><br><span class="line">        if (retry == null) &#123;</span><br><span class="line">            annotation.setRetryAnalyzer(TestNGRetry.class);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-在testng-xml文件中配置自己编写的监听器"><a href="#3-在testng-xml文件中配置自己编写的监听器" class="headerlink" title="3. 在testng.xml文件中配置自己编写的监听器"></a>3. 在testng.xml文件中配置自己编写的监听器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;listeners&gt;</span><br><span class="line">&lt;listener class-name=&quot;com.dji.utils.TestNGListener&quot; /&gt;</span><br><span class="line">&lt;listener class-name=&quot;com.dji.utils.RetryListener&quot;/&gt;</span><br><span class="line">&lt;/listeners&gt;</span><br></pre></td></tr></table></figure><h3 id="4-进一步改进"><a href="#4-进一步改进" class="headerlink" title="4. 进一步改进"></a>4. 进一步改进</h3><p>以上三步就搞定用例失败重跑的功能了，但是最后我们查看testng报告时，发现失败的用例在报告里生成了多份，显然这样不好，那怎么解决呢？<br><img src="http://img.blog.csdn.net/20160928163349572" alt="这里写图片描述"></p><p>我们来更改第一部分自动截图中说到的TestNGListener监听器类，重写onFinish方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onFinish(ITestContext testContext) &#123;</span><br><span class="line">log.info(&quot;Test Finish&quot;);</span><br><span class="line"></span><br><span class="line">       Iterator&lt;ITestResult&gt; listOfFailedTests = testContext.getFailedTests().getAllResults().iterator();</span><br><span class="line">       while (listOfFailedTests.hasNext()) &#123;</span><br><span class="line">           ITestResult failedTest = listOfFailedTests.next();</span><br><span class="line">           ITestNGMethod method = failedTest.getMethod();</span><br><span class="line">           if (testContext.getFailedTests().getResults(method).size() &gt; 1) &#123;</span><br><span class="line">               listOfFailedTests.remove();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               if (testContext.getPassedTests().getResults(method).size() &gt; 0) &#123;</span><br><span class="line">                   listOfFailedTests.remove();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在前面我的自动化
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="自动化测试" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>UI层自动化测试框架（六）：持续集成和测试报告</title>
    <link href="http://yoursite.com/2016/12/01/UI%E5%B1%82%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%92%8C%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A/"/>
    <id>http://yoursite.com/2016/12/01/UI层自动化测试框架（六）：持续集成和测试报告/</id>
    <published>2016-12-01T05:31:20.000Z</published>
    <updated>2018-05-01T11:54:11.709Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><p>前面几章讲解了测试框架的结构和实现，接下来讲解如何实现测试框架的自动化和测试报告的生成。</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>本框架我是采用Jenkins实现持续集成的，至于Jenkins环境的搭建和使用，我前面的blog有提到，如果大家不清楚的可以先去阅读我之前写的这篇文章，<a href="http://blog.csdn.net/tobetheender/article/details/52298583" target="_blank" rel="noopener">Jenkins安装和构建部署</a></p><ul><li><p>运行jenkins，首先创建一个job为appiumTurbo</p><p><img src="http://img.blog.csdn.net/20160913210338318" alt="这里写图片描述"></p></li><li><p>源码管理<br>将代码上传到github上进行托管，然后在jenkins上配置clone 到你本地或者远程的jenkins来：<br><img src="http://img.blog.csdn.net/20160913213358331" alt="这里写图片描述"></p></li><li><p>构建触发器<br>Poll SCM： 定时检查源码变更（根据SCM软件的版本号），如果有更新就checkout最新code下来，然后执行构建动作。Build periodically：周期进行项目构建（它不care源码是否发生变化），我的配置如下：<br>每天凌晨2：00进行一次构建</p></li></ul><p><img src="http://img.blog.csdn.net/20160913213817598" alt="这里写图片描述"></p><ul><li><p>构建</p><p><img src="http://img.blog.csdn.net/20160913213247424" alt="这里写图片描述"></p></li><li><p>构建后操作<br>发送邮件</p></li></ul><hr><h2 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h2><p>每次构建完成后都会生成一个测试报告，由于testng自带生成测试报告，但是这个报告比较丑陋，下面开始用ReportNG来生成漂亮简洁的测试报告。</p><ul><li>在maven项目中添加依赖，在pom.xml文件中添加以下依赖关系：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 依赖reportNg 关联testNg --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.uncommons&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;reportng&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.1.4&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;exclusions&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;org.testng&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;testng&lt;/artifactId&gt;</span><br><span class="line">&lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 依赖Guice --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.google.inject&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;guice&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;3.0&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>配置maven-surefire-plugin并加入reportNG listenser</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;!-- 添加插件,关联testNg.xml,添加ReportNg的监听器，修改最后的TestNg的报告 --&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;2.18.1&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">&lt;suiteXmlFiles&gt;</span><br><span class="line">&lt;!-- &lt;suiteXmlFile&gt;res/$&#123;xmlFileName&#125;&lt;/suiteXmlFile&gt; --&gt;</span><br><span class="line">&lt;suiteXmlFile&gt;testng.xml&lt;/suiteXmlFile&gt;</span><br><span class="line">&lt;/suiteXmlFiles&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;usedefaultlisteners&lt;/name&gt;</span><br><span class="line">&lt;value&gt;false&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;listener&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.uncommons.reportng.HTMLReporter,</span><br><span class="line">org.uncommons.reportng.JUnitXMLReporter&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;workingDirectory&gt;target/&lt;/workingDirectory&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><ul><li>最后构建完成后，在target目录下创建了一个surefire-reports目录，打开它下面的html文件夹，打开indel.xml，就可以看到相对美观的报告形式了，类似如图：</li></ul><p><img src="http://img.blog.csdn.net/20160928151854269" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面几章讲解了测试框架的结构和实现，接下来讲解如何实现测试框架的自动化和测试报告的生成。&lt;/p&gt;
&lt;h2 id=&quot;持续集成&quot;&gt;&lt;a href=&quot;#持续
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="自动化测试" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>UI层自动化测试框架（五）：业务层和用例层</title>
    <link href="http://yoursite.com/2016/12/01/UI%E5%B1%82%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E4%B8%9A%E5%8A%A1%E5%B1%82%E5%92%8C%E7%94%A8%E4%BE%8B%E5%B1%82/"/>
    <id>http://yoursite.com/2016/12/01/UI层自动化测试框架（五）：业务层和用例层/</id>
    <published>2016-11-30T16:52:10.000Z</published>
    <updated>2018-05-01T11:52:44.757Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为CharliChen原创文章，转载请注明出处！！</p></blockquote><h2 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h2><p>该层主要是App的各种业务操作，比如登录，遍历tab，下单等，也就是说把app中各项业务的操作都封装在业务层。比如说登录操作，我们把它封装一个类，登录的大致的流程是：首先是不是要找到登录入口（可能一个app有很多的入口），然后进入登录界面，输入用户名和密码，再点击登录按钮，这样一个完整的登录业务就算完成了。</p><p>可能你问我为什么要这么做呢？在测试脚本中直接写不就可以了，为什么要把它们分离出来？其实这样做的目的是为了最大程度让测试用例维护性降低。如果以后需求发生变化，比如登陆的逻辑中增加了验证码等，这时只用改业务层中的登录类就可以了，而用例层中的测试脚本并不用改。</p><p><img src="http://img.blog.csdn.net/20160913120721508" alt="这里写图片描述"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">以下为登录业务的代码：</span><br><span class="line"></span><br><span class="line">package com.dji.action;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import com.dji.object.BasePage;</span><br><span class="line">import io.appium.java_client.AppiumDriver;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 登录action</span><br><span class="line"> * @author charlie.chen</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Login  &#123;</span><br><span class="line">   </span><br><span class="line"> private AppiumDriver&lt;?&gt; driver;</span><br><span class="line"></span><br><span class="line"> private BasePage loginPage=null;</span><br><span class="line"></span><br><span class="line">public Login(AppiumDriver&lt;?&gt; driver) &#123;</span><br><span class="line">this.driver = driver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//通过登录按钮登录</span><br><span class="line">public void loginByButton(String userName,String pwd) throws Exception&#123;</span><br><span class="line">new BasePage(driver,&quot;menuPage&quot;).click(&quot;我&quot;);</span><br><span class="line">isLogined();</span><br><span class="line">new BasePage(driver,&quot;minePageNo&quot;).click(&quot;登录&quot;);</span><br><span class="line">login(userName,pwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//通过DJI Store登录</span><br><span class="line">public void loginByStore(String email,String pwd) throws Exception&#123;</span><br><span class="line">isLogined();</span><br><span class="line">new BasePage(driver,&quot;minePageNo&quot;).click(&quot;DJI商城&quot;);</span><br><span class="line">login(email,pwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 通过DJI Academy登录</span><br><span class="line">public void loginByAcademy(String email,String pwd) throws Exception&#123;</span><br><span class="line">isLogined();</span><br><span class="line">new BasePage(driver,&quot;minePageNo&quot;).click(&quot;DJI论坛&quot;);</span><br><span class="line">login(email,pwd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//判断是否已登录，如果已登录就先退出登录</span><br><span class="line">public void isLogined() throws Exception&#123;</span><br><span class="line">BasePage minePage=new BasePage(driver,&quot;minePage&quot;);</span><br><span class="line">boolean flag=minePage.isElementDisplayed(&quot;用户图像&quot;);</span><br><span class="line">if(flag)&#123;</span><br><span class="line">minePage.swipeToUp();</span><br><span class="line">driver.manage().timeouts().implicitlyWait(20, TimeUnit.SECONDS);</span><br><span class="line">minePage.click(&quot;设置&quot;);</span><br><span class="line">loginOut();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//登录操作</span><br><span class="line">public  void login(String userName,String pwd) throws Exception &#123;</span><br><span class="line">loginPage=new BasePage(driver,&quot;loginPage&quot;);</span><br><span class="line">loginPage.type(&quot;登录输入账号框&quot;, userName);</span><br><span class="line">loginPage.type(&quot;登录输入密码框&quot;, pwd);</span><br><span class="line">loginPage.click(&quot;登录&quot;);</span><br><span class="line">driver.manage().timeouts().implicitlyWait(20, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//退出登录</span><br><span class="line">public void loginOut() throws Exception&#123;</span><br><span class="line">BasePage settingPage=new BasePage(driver,&quot;settingPage&quot;);</span><br><span class="line">settingPage.click(&quot;退出DJI账号&quot;);</span><br><span class="line">settingPage.click(&quot;确定&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="用例层"><a href="#用例层" class="headerlink" title="用例层"></a>用例层</h2><p>该层是实际的测试脚本，也就是调用业务层中的各项业务操作，然后增加验证，判定结果是否正确。</p><p>以下为登录用例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">package com.dji.cases;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">import org.testng.annotations.AfterClass;</span><br><span class="line">import org.testng.annotations.AfterMethod;</span><br><span class="line">import org.testng.annotations.AfterTest;</span><br><span class="line">import org.testng.annotations.BeforeClass;</span><br><span class="line">import org.testng.annotations.BeforeMethod;</span><br><span class="line">import org.testng.annotations.BeforeTest;</span><br><span class="line">import org.testng.annotations.Listeners;</span><br><span class="line">import org.testng.annotations.Parameters;</span><br><span class="line">import org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line">import static org.assertj.core.api.Java6Assertions.*;</span><br><span class="line"></span><br><span class="line">import com.dji.action.Login;</span><br><span class="line">import com.dji.object.BasePage;</span><br><span class="line">import com.dji.utils.DriverFactory;</span><br><span class="line">import com.dji.utils.TestNGListener;</span><br><span class="line"></span><br><span class="line">import io.appium.java_client.android.AndroidDriver;</span><br><span class="line"></span><br><span class="line">@Listeners(&#123; TestNGListener.class &#125;)</span><br><span class="line">public class LoginTest &#123;</span><br><span class="line"></span><br><span class="line">private AndroidDriver&lt;?&gt; ad = null;</span><br><span class="line">private Login login = null;</span><br><span class="line"></span><br><span class="line">@Parameters(&#123; &quot;userName&quot;, &quot;pwd&quot; &#125;)</span><br><span class="line">@Test(description = &quot;通过登录按钮登录&quot;)</span><br><span class="line">public void loginByButton(String userName, String pwd) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">login.loginByButton(userName, pwd);</span><br><span class="line">ad.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);</span><br><span class="line">// 断言验证用户名是否正确</span><br><span class="line">//Assert.assertEquals(new BasePage(ad, &quot;minePage&quot;).findElement(&quot;用户名&quot;).getText(), &quot;charlie.chen&quot;);   //testNG自带的断言机制</span><br><span class="line">//采用AssertJ断言机制</span><br><span class="line">assertThat(new BasePage(ad, &quot;minePage&quot;).findElement(&quot;用户名&quot;).getText()).isEqualTo(&quot;charlie.chen&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Parameters(&#123; &quot;userName&quot;, &quot;pwd&quot; &#125;)</span><br><span class="line">@Test(description = &quot;通过DJI Store登录&quot;)</span><br><span class="line">public void loginByStore(String userName, String pwd) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">login.loginByStore(userName, pwd);</span><br><span class="line">ad.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Parameters(&#123; &quot;userName&quot;, &quot;pwd&quot; &#125;)</span><br><span class="line">@Test(description = &quot;通过DJI论坛登录&quot;)</span><br><span class="line">public void loginByAcademy(String userName, String pwd) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">login.loginByAcademy(userName, pwd);</span><br><span class="line">ad.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Parameters(&#123; &quot;userName&quot;, &quot;pwd&quot; &#125;)</span><br><span class="line">@Test(description = &quot;通过飞行记录登录&quot;)</span><br><span class="line">public void loginByFly(String userName, String pwd) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// /*</span><br><span class="line">// * 通过Skypixel关注登录</span><br><span class="line">// */</span><br><span class="line">// @Test</span><br><span class="line">// public void loginByAttention() throws Exception &#123;</span><br><span class="line">// &#125;</span><br><span class="line">//</span><br><span class="line">// /*</span><br><span class="line">// * 通过Skypixel点赞登录</span><br><span class="line">// */</span><br><span class="line">// @Test</span><br><span class="line">// public void loginByPraise() throws Exception &#123;</span><br><span class="line">// &#125;</span><br><span class="line">//</span><br><span class="line">// /*</span><br><span class="line">// * 通过Skypixel收藏登录</span><br><span class="line">// */</span><br><span class="line">// @Test</span><br><span class="line">// public void loginByCollect() throws Exception &#123;</span><br><span class="line">// &#125;</span><br><span class="line">//</span><br><span class="line">// /*</span><br><span class="line">// * 通过Skypixel评论登录</span><br><span class="line">// */</span><br><span class="line">// @Test</span><br><span class="line">// public void loginByComment() throws Exception &#123;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">@BeforeMethod</span><br><span class="line">public void beforeMethod() throws Exception &#123;</span><br><span class="line">login = new Login(ad);</span><br><span class="line">TestNGListener.setDriver(ad);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterMethod</span><br><span class="line">public void afterMethod() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@BeforeClass</span><br><span class="line">public void beforeClass() &#123;</span><br><span class="line"></span><br><span class="line">ad = DriverFactory.createAndroidDriver(&quot;PBV0216615001449&quot;, &quot;4723&quot;, &quot;dji.pilot&quot;, &quot;dji.pilot.main.activity.DJIAoaActivity&quot;); </span><br><span class="line">ad.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterClass</span><br><span class="line">public void afterClass() &#123;</span><br><span class="line">// ad.closeApp();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@BeforeTest()</span><br><span class="line">public void beforeTest() throws Exception &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@AfterTest</span><br><span class="line">public void afterTest() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>testng.xml文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot; &gt;</span><br><span class="line">&lt;suite name=&quot;appiumPRO&quot; parallel=&quot;false&quot; preserve-order=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;parameter name=&quot;port&quot; value=&quot;4723&quot; /&gt;</span><br><span class="line">&lt;parameter name=&quot;udid&quot; value=&quot;PBV0216615001449&quot; /&gt;</span><br><span class="line">&lt;parameter name=&quot;appPackage&quot; value=&quot;dji.pilot&quot; /&gt;</span><br><span class="line">&lt;parameter name=&quot;appActivity&quot; value=&quot;dji.pilot.main.activity.DJIAoaActivity&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;parameter name=&quot;userName&quot; value=&quot;charlie.chen@dji.com&quot; /&gt;</span><br><span class="line">&lt;parameter name=&quot;pwd&quot; value=&quot;1weefdsew&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;test name=&quot;LoginTest&quot; preserve-order=&quot;true&quot;&gt;</span><br><span class="line">&lt;classes&gt;</span><br><span class="line">&lt;class name=&quot;com.dji.cases.LoginTest&quot; &gt;</span><br><span class="line">&lt;methods&gt;</span><br><span class="line">&lt;include name=&quot;loginByButton&quot; /&gt;</span><br><span class="line">&lt;include name=&quot;loginByStore&quot; /&gt;</span><br><span class="line">&lt;exclude name=&quot;loginByAcademy&quot; /&gt;</span><br><span class="line">&lt;exclude name=&quot;loginByFly&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;exclude name=&quot;loginByAttention&quot; /&gt;</span><br><span class="line">&lt;exclude name=&quot;loginByPraise&quot; /&gt;</span><br><span class="line">&lt;exclude name=&quot;loginByCollect&quot; /&gt;</span><br><span class="line">&lt;exclude name=&quot;loginByComment&quot; /&gt;</span><br><span class="line">&lt;/methods&gt;</span><br><span class="line">&lt;/class&gt;</span><br><span class="line">&lt;/classes&gt;</span><br><span class="line">&lt;/test&gt;</span><br><span class="line"></span><br><span class="line">&lt;/suite&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为CharliChen原创文章，转载请注明出处！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;业务层&quot;&gt;&lt;a href=&quot;#业务层&quot; class=&quot;headerlink&quot; title=&quot;业务层&quot;&gt;&lt;/a&gt;业务层&lt;/h2&gt;&lt;p&gt;该层主要
      
    
    </summary>
    
      <category term="测试开发" scheme="http://yoursite.com/categories/%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="自动化测试" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
